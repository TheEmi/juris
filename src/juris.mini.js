(function () { "use strict"; const jurisLinesOfCode = 2839, jurisVersion = "0.86.0", jurisMinifiedSize = "57.23 kB", isValidPath = e => "string" == typeof e && e.trim().length > 0 && !e.includes(".."), getPathParts = e => e.split(".").filter(Boolean), deepEquals = (e, t) => { if (e === t) return !0; if (null == e || null == t || typeof e != typeof t) return !1; if ("object" == typeof e) { if (Array.isArray(e) !== Array.isArray(t)) return !1; const n = Object.keys(e), s = Object.keys(t); return n.length === s.length && n.every((n => s.includes(n) && deepEquals(e[n], t[n]))) } return !1 }, createLogger = () => { const e = [], f = (t, n, s) => { const r = { formatted: `${s ? `[${s}] ` : ""}${t}${n ? ` ${JSON.stringify(n)}` : ""}`, message: t, context: n, category: s, timestamp: Date.now() }; return setTimeout((() => e.forEach((e => e(r)))), 0), r }; return { log: { l: f, w: f, e: f, i: f, d: f }, sub: t => e.push(t), unsub: t => e.splice(e.indexOf(t), 1) } }, { log: log, logSub: logSub, logUnsub: logUnsub } = createLogger(), createPromisify = () => { const e = new Set; let t = !1; const n = new Set, checkAllComplete = () => { 0 === e.size && n.size > 0 && n.forEach((e => e())) }; return { promisify: n => { const s = n?.then ? n : Promise.resolve(n); return t && s !== n && (e.add(s), s.finally((() => { e.delete(s), setTimeout(checkAllComplete, 0) }))), s }, startTracking: () => { t = !0, e.clear() }, stopTracking: () => { t = !1, n.clear() }, onAllComplete: t => (n.add(t), 0 === e.size && setTimeout(t, 0), () => n.delete(t)) } }, { promisify: promisify, startTracking: startTracking, stopTracking: stopTracking, onAllComplete: onAllComplete } = createPromisify(); class StateManager { constructor(e = {}, t = []) { console.info(log.i("StateManager initialized", { initialStateKeys: Object.keys(e), middlewareCount: t.length }, "framework")), this.state = { ...e }, this.middleware = [...t], this.subscribers = new Map, this.externalSubscribers = new Map, this.currentTracking = null, this.isUpdating = !1, this.initialState = JSON.parse(JSON.stringify(e)), this.maxUpdateDepth = 50, this.updateDepth = 0, this.currentlyUpdating = new Set, this.isBatching = !1, this.batchQueue = [], this.batchedPaths = new Set } reset() { console.info(log.i("State reset to initial state", {}, "framework")), this.isBatching && (this.batchQueue = [], this.batchedPaths.clear(), this.isBatching = !1), this.state = JSON.parse(JSON.stringify(this.initialState)) } getState(e, t = null, n = !0) { if (!isValidPath(e)) return t; n && this.currentTracking?.add(e); const s = getPathParts(e); let r = this.state; for (const e of s) { if (void 0 === r?.[e]) return t; r = r[e] } return r } setState(e, t, n = {}) { console.debug(log.d("State change initiated", { path: e, hasValue: void 0 !== t }, "application")), isValidPath(e) && !this._hasCircularUpdate(e) && (this.isBatching ? this._queueBatchedUpdate(e, t, n) : this._setStateImmediate(e, t, n)) } executeBatch(e) { if (this.isBatching) return e(); this.beginBatch(); try { const t = e(); return t && "function" == typeof t.then ? t.then((e => (this.endBatch(), e))).catch((e => { throw this.endBatch(), e })) : (this.endBatch(), t) } catch (e) { throw this.endBatch(), e } } beginBatch() { console.debug(log.d("Manual batch started", {}, "framework")), this.isBatching = !0, this.batchQueue = [], this.batchedPaths.clear() } endBatch() { this.isBatching ? (console.debug(log.d("Manual batch ending", { queuedUpdates: this.batchQueue.length }, "framework")), this.isBatching = !1, 0 !== this.batchQueue.length && this._processBatchedUpdates()) : console.warn(log.w("endBatch() called without beginBatch()", {}, "framework")) } isBatchingActive() { return this.isBatching } getBatchQueueSize() { return this.batchQueue.length } clearBatch() { this.isBatching && (console.info(log.i("Clearing current batch", { clearedUpdates: this.batchQueue.length }, "framework")), this.batchQueue = [], this.batchedPaths.clear()) } _queueBatchedUpdate(e, t, n) { this.batchQueue = this.batchQueue.filter((t => t.path !== e)), this.batchQueue.push({ path: e, value: t, context: n, timestamp: Date.now() }), this.batchedPaths.add(e) } _processBatchedUpdates() { const e = [...this.batchQueue]; this.batchQueue = [], this.batchedPaths.clear(); const t = new Map; e.forEach((e => t.set(e.path, e))); const n = this.isUpdating; this.isUpdating = !0; const s = []; t.forEach((e => { const t = this.getState(e.path); let n = e.value; for (const s of this.middleware) try { const r = s({ path: e.path, oldValue: t, newValue: n, context: e.context, state: this.state }); void 0 !== r && (n = r) } catch (t) { console.error(log.e("Middleware error in batch", { path: e.path, error: t.message }, "application")) } if (deepEquals(t, n)) return; const r = getPathParts(e.path); let i = this.state; for (let e = 0; e < r.length - 1; e++) { const t = r[e]; null != i[t] && "object" == typeof i[t] || (i[t] = {}), i = i[t] } i[r[r.length - 1]] = n, s.push({ path: e.path, oldValue: t, newValue: n }) })), this.isUpdating = n; const r = new Set; s.forEach((({ path: e }) => { const t = getPathParts(e); for (let e = 1; e <= t.length; e++)r.add(t.slice(0, e).join(".")) })), r.forEach((e => { this.subscribers.has(e) && this._triggerPathSubscribers(e), this.externalSubscribers.has(e) && this.externalSubscribers.get(e).forEach((({ callback: t, hierarchical: n }) => { try { t(this.getState(e), null, e) } catch (e) { console.error(log.e("External subscriber error:", e), "application") } })) })) } _setStateImmediate(e, t, n = {}) { const s = this.getState(e); let r = t; for (const t of this.middleware) try { const i = t({ path: e, oldValue: s, newValue: r, context: n, state: this.state }); void 0 !== i && (r = i) } catch (n) { console.error(log.e("Middleware error", { path: e, error: n.message, middlewareName: t.name || "anonymous" }, "application")) } if (deepEquals(s, r)) return void console.debug(log.d("State unchanged, skipping update", { path: e }, "framework")); console.debug(log.d("State updated", { path: e, oldValue: typeof s, newValue: typeof r }, "application")); const i = getPathParts(e); let o = this.state; for (let e = 0; e < i.length - 1; e++) { const t = i[e]; null != o[t] && "object" == typeof o[t] || (o[t] = {}), o = o[t] } o[i[i.length - 1]] = r, this.isUpdating || (this.isUpdating = !0, this.currentlyUpdating || (this.currentlyUpdating = new Set), this.currentlyUpdating.add(e), this._notifySubscribers(e, r, s), this._notifyExternalSubscribers(e, r, s), this.currentlyUpdating.delete(e), this.isUpdating = !1) } subscribe(e, t, n = !0) { this.externalSubscribers.has(e) || this.externalSubscribers.set(e, new Set); const s = { callback: t, hierarchical: n }; return this.externalSubscribers.get(e).add(s), () => { const t = this.externalSubscribers.get(e); t && (t.delete(s), 0 === t.size && this.externalSubscribers.delete(e)) } } subscribeExact(e, t) { return this.subscribe(e, t, !1) } subscribeInternal(e, t) { return this.subscribers.has(e) || this.subscribers.set(e, new Set), this.subscribers.get(e).add(t), () => { const n = this.subscribers.get(e); n && (n.delete(t), 0 === n.size && this.subscribers.delete(e)) } } _notifySubscribers(e, t, n) { this._triggerPathSubscribers(e); const s = getPathParts(e); for (let e = s.length - 1; e > 0; e--)this._triggerPathSubscribers(s.slice(0, e).join(".")); const r = e ? e + "." : ""; new Set([...this.subscribers.keys(), ...this.externalSubscribers.keys()]).forEach((t => { t.startsWith(r) && t !== e && this._triggerPathSubscribers(t) })) } _notifyExternalSubscribers(e, t, n) { this.externalSubscribers.forEach(((s, r) => { s.forEach((({ callback: s, hierarchical: i }) => { if (i ? e === r || e.startsWith(r + ".") : e === r) try { s(t, n, e) } catch (e) { console.error(log.e("External subscriber error:", e), "application") } })) })) } _triggerPathSubscribers(e) { const t = this.subscribers.get(e); t && t.size > 0 && (console.debug(log.d("Triggering subscribers", { path: e, subscriberCount: t.size }, "framework")), new Set(t).forEach((e => { let t; try { t = this.currentTracking; const n = new Set; this.currentTracking = n, e(), this.currentTracking = t, n.forEach((t => { const n = this.subscribers.get(t); n && n.has(e) || this.subscribeInternal(t, e) })) } catch (e) { console.error(log.e("Subscriber error:", e), "application"), this.currentTracking = t } }))) } _hasCircularUpdate(e) { return this.currentlyUpdating || (this.currentlyUpdating = new Set), !!this.currentlyUpdating.has(e) && (console.warn(log.w("Circular dependency detected", { path: e }, "framework")), !0) } startTracking() { const e = new Set; return this.currentTracking = e, e } endTracking() { const e = this.currentTracking; return this.currentTracking = null, e || new Set } } class HeadlessManager { constructor(e) { console.info(log.i("HeadlessManager initialized", {}, "framework")), this.juris = e, this.components = new Map, this.instances = new Map, this.context = {}, this.initQueue = new Set, this.lifecycleHooks = new Map } register(e, t, n = {}) { console.info(log.i("Headless component registered", { name: e, hasOptions: Object.keys(n).length > 0 }, "framework")), this.components.set(e, { fn: t, options: n }), n.autoInit && this.initQueue.add(e) } initialize(e, t = {}) { console.debug(log.d("Initializing headless component", { name: e, propsKeys: Object.keys(t) }, "framework")); const n = this.components.get(e); if (!n) return console.error(log.e("Headless component not found", { name: e }, "framework")), null; try { const s = this.juris.createHeadlessContext(), r = n.fn(t, s); return r && "object" == typeof r ? (console.info(log.i("Headless component initialized", { name: e, hasAPI: !!r.api, hasHooks: !!r.hooks }, "framework")), this.instances.set(e, r), r.hooks && this.lifecycleHooks.set(e, r.hooks), r.api && (this.context[e] = r.api, this.juris.headlessAPIs || (this.juris.headlessAPIs = {}), this.juris.headlessAPIs[e] = r.api, this.juris._updateComponentContexts()), r.hooks?.onRegister?.(), r) : (console.error(log.e("Invalid headless component instance", { name: e }, "framework")), null) } catch (t) { return console.error(log.e("Headless component initialization failed", { name: e, error: t.message }, "framework")), null } } initializeQueued() { this.initQueue.forEach((e => { if (!this.instances.has(e)) { const t = this.components.get(e); this.initialize(e, t.options || {}) } })), this.initQueue.clear() } getInstance(e) { return this.instances.get(e) } getAPI(e) { return this.context[e] } getAllAPIs() { return { ...this.context } } reinitialize(e, t = {}) { const n = this.instances.get(e); if (n?.hooks?.onUnregister) try { n.hooks.onUnregister() } catch (t) { console.error(log.e(`Error in onUnregister for '${e}':`, t), "framework") } return this.context[e] && delete this.context[e], this.juris.headlessAPIs?.[e] && delete this.juris.headlessAPIs[e], this.instances.delete(e), this.lifecycleHooks.delete(e), this.initialize(e, t) } cleanup() { console.info(log.i("Cleaning up headless components", { instanceCount: this.instances.size }, "framework")), this.instances.forEach(((e, t) => { if (e.hooks?.onUnregister) try { e.hooks.onUnregister() } catch (e) { console.error(log.e(`Error in onUnregister for '${t}':`, e), "framework") } })), this.instances.clear(), this.context = {}, this.lifecycleHooks.clear(), this.juris.headlessAPIs && (this.juris.headlessAPIs = {}) } getStatus() { return { registered: Array.from(this.components.keys()), initialized: Array.from(this.instances.keys()), queued: Array.from(this.initQueue), apis: Object.keys(this.context) } } } class ComponentManager { constructor(e) { console.info(log.i("ComponentManager initialized", {}, "framework")), this.juris = e, this.components = new Map, this.instances = new WeakMap, this.componentCounters = new Map, this.componentStates = new WeakMap, this.asyncPlaceholders = new WeakMap, this.asyncPropsCache = new Map } register(e, t) { console.info(log.i("Component registered", { name: e }, "application")), this.components.set(e, t) } create(e, t = {}) { const n = this.components.get(e); if (!n) return console.error(log.e("Component not found", { name: e }, "application")), null; try { if (this._hasAsyncProps(t)) return console.debug(log.d("Component has async props", { name: e }, "framework")), this._createWithAsyncProps(e, n, t); const { componentId: s, componentStates: r } = this._setupComponent(e); console.debug(log.d("Component setup complete", { name: e, componentId: s, stateCount: r.size }, "framework")); const i = n(t, this._createComponentContext(s, r)); return i?.then ? this._handleAsyncComponent(promisify(i), e, t, r) : this._processComponentResult(i, e, t, r) } catch (t) { return console.error(log.e("Component creation failed", { name: e, error: t.message }, "application")), this._createErrorElement(t) } } _setupComponent(e) { this.componentCounters.has(e) || this.componentCounters.set(e, 0); const t = this.componentCounters.get(e) + 1; this.componentCounters.set(e, t); return { componentId: `${e}_${t}`, componentStates: new Set } } _createComponentContext(e, t) { const n = this.juris.createContext(); return n.newState = (n, s) => { const r = `__local.${e}.${n}`; return this.juris.stateManager.getState(r, Symbol("not-found")) === Symbol("not-found") && this.juris.stateManager.setState(r, s), t.add(r), [() => this.juris.stateManager.getState(r, s), e => this.juris.stateManager.setState(r, e)] }, n } _hasAsyncProps(e) { return Object.values(e).some((e => e?.then)) } _createWithAsyncProps(e, t, n) { console.debug(log.d("Creating component with async props", { name: e }, "framework")); const s = document.createElement("div"); s.id = e.toLowerCase().replace(/[^a-z0-9]/g, "-"); const r = this._createPlaceholder(`Loading ${e}...`, "juris-async-props-loading", s); return this.asyncPlaceholders.set(r, { name: e, props: n, type: "async-props" }), this._resolveAsyncProps(n).then((n => { try { const s = this._createSyncComponent(e, t, n); s && r.parentNode && r.parentNode.replaceChild(s, r), this.asyncPlaceholders.delete(r) } catch (e) { this._replaceWithError(r, e) } })).catch((e => this._replaceWithError(r, e))), r } async _resolveAsyncProps(e) { const t = this._generateCacheKey(e), n = this.asyncPropsCache.get(t); if (n && Date.now() - n.timestamp < 5e3) return n.props; const s = {}; for (const [t, n] of Object.entries(e)) if (n?.then) try { s[t] = await n } catch (e) { s[t] = { __asyncError: e.message } } else s[t] = n; return this.asyncPropsCache.set(t, { props: s, timestamp: Date.now() }), s } _generateCacheKey(e) { return JSON.stringify(e, ((e, t) => t?.then ? "[Promise]" : t)) } _createSyncComponent(e, t, n) { const { componentId: s, componentStates: r } = this._setupComponent(e), i = t(n, this._createComponentContext(s, r)); return i?.then ? this._handleAsyncComponent(promisify(i), e, n, r) : this._processComponentResult(i, e, n, r) } _handleAsyncComponent(e, t, n, s) { console.debug(log.d("Handling async component", { name: t }, "framework")); const r = document.createElement("div"); r.id = t.toLowerCase().replace(/[^a-z0-9]/g, "-"); const i = this._createPlaceholder(`Loading ${t}...`, "juris-async-loading", r); return this.asyncPlaceholders.set(i, { name: t, props: n, componentStates: s }), e.then((e => { console.debug(log.d("Async component resolved", { name: t }, "framework")); try { const r = this._processComponentResult(e, t, n, s); r && i.parentNode && i.parentNode.replaceChild(r, i), this.asyncPlaceholders.delete(i) } catch (e) { console.error(log.e("Async component failed", { name: t, error: e.message }, "application")), this._replaceWithError(i, e) } })).catch((e => this._replaceWithError(i, e))), i } _processComponentResult(e, t, n, s) { if (e && "object" == typeof e) { if (this._hasLifecycleHooks(e)) return this._createLifecycleComponent(e, t, n, s); if ("function" == typeof e.render && !this._hasLifecycleHooks(e)) { const n = e.render(); if (n?.then) return this._handleAsyncRender(promisify(n), t, s, e.indicator); const r = this.juris.domRenderer.render(n); return r && s.size > 0 && this.componentStates.set(r, s), r } const r = Object.keys(e); if (1 === r.length && "string" == typeof r[0] && r[0].length > 0) { const t = this.juris.domRenderer.render(e); return t && s.size > 0 && this.componentStates.set(t, s), t } } const r = this.juris.domRenderer.render(e); return r && s.size > 0 && this.componentStates.set(r, s), r } _hasLifecycleHooks(e) { return e.hooks && (e.hooks.onMount || e.hooks.onUpdate || e.hooks.onUnmount) || e.onMount || e.onUpdate || e.onUnmount } _handleAsyncRender(e, t, n, s = null) { const r = document.createElement("div"); r.id = t.toLowerCase().replace(/[^a-z0-9]/g, "-"); const i = s ? this.juris.domRenderer.render(s) : this._createPlaceholder(`Loading ${t}...`, "juris-async-loading", r); return e.then((e => { try { const t = this.juris.domRenderer.render(e); t && n.size > 0 && this.componentStates.set(t, n), i.parentNode && i.parentNode.replaceChild(t, i) } catch (e) { this._replaceWithError(i, e) } })).catch((e => this._replaceWithError(i, e))), i } _createLifecycleComponent(e, t, n, s) { const r = { name: t, props: n, hooks: e.hooks || {}, api: e.api || {}, render: e.render }, i = r.render(); if (i?.then) return this._handleAsyncLifecycleRender(promisify(i), r, s); const o = this.juris.domRenderer.render(i); return o && (this.instances.set(o, r), s?.size > 0 && this.componentStates.set(o, s), r.hooks.onMount && setTimeout((() => { try { const e = r.hooks.onMount(); e?.then && promisify(e).catch((e => console.error(log.e(`Async onMount error in ${t}:`, e), "application"))) } catch (e) { console.error(log.e(`onMount error in ${t}:`, e), "application") } }), 0)), o } _handleAsyncLifecycleRender(e, t, n) { const s = document.createElement("div"); s.id = t.name.toLowerCase().replace(/[^a-z0-9]/g, "-"); const r = this._createPlaceholder(`Loading ${t.name}...`, "juris-async-lifecycle", s); return e.then((e => { try { const s = this.juris.domRenderer.render(e); s && (this.instances.set(s, t), n?.size > 0 && this.componentStates.set(s, n), r.parentNode && r.parentNode.replaceChild(s, r), t.hooks.onMount && setTimeout((() => { try { const e = t.hooks.onMount(); e?.then && promisify(e).catch((e => console.error(log.e(`Async onMount error in ${t.name}:`, e), "application"))) } catch (e) { console.error(log.e(`onMount error in ${t.name}:`, e), "application") } }), 0)) } catch (e) { this._replaceWithError(r, e) } })).catch((e => this._replaceWithError(r, e))), r } updateInstance(e, t) { const n = this.instances.get(e); if (!n) return; const s = n.props; deepEquals(s, t) || (this._hasAsyncProps(t) ? this._resolveAsyncProps(t).then((t => { n.props = t, this._performUpdate(n, e, s, t) })).catch((e => console.error(log.e(`Error updating async props for ${n.name}:`, e), "application"))) : (n.props = t, this._performUpdate(n, e, s, t))) } _performUpdate(e, t, n, s) { if (e.hooks.onUpdate) try { const t = e.hooks.onUpdate(n, s); t?.then && promisify(t).catch((t => console.error(log.e(`Async onUpdate error in ${e.name}:`, t), "application"))) } catch (t) { console.error(log.e(`onUpdate error in ${e.name}:`, t), "application") } try { const n = e.render(), s = promisify(n); s !== n ? s.then((e => { this.juris.domRenderer.updateElementContent(t, e) })).catch((t => console.error(log.e(`Async re-render error in ${e.name}:`, t), "application"))) : this.juris.domRenderer.updateElementContent(t, n) } catch (t) { console.error(log.e(`Re-render error in ${e.name}:`, t), "application") } } cleanup(e) { const t = this.instances.get(e); if (t && console.debug(log.d("Cleaning up component", { name: t.name }, "framework")), t?.hooks?.onUnmount) try { const e = t.hooks.onUnmount(); e?.then && promisify(e).catch((e => console.error(log.e(`Async onUnmount error in ${t.name}:`, e), "application"))) } catch (e) { console.error(log.e(`onUnmount error in ${t.name}:`, e), "application") } const n = this.componentStates.get(e); n && (n.forEach((e => { const t = e.split("."); let n = this.juris.stateManager.state; for (let e = 0; e < t.length - 1; e++) { if (!n[t[e]]) return; n = n[t[e]] } delete n[t[t.length - 1]] })), this.componentStates.delete(e)), this.asyncPlaceholders.has(e) && this.asyncPlaceholders.delete(e), this.instances.delete(e) } _createPlaceholder(e, t, n = null) { const s = this.juris.domRenderer._getPlaceholderConfig(n), r = document.createElement("div"); return r.className = s.className, r.textContent = s.text, s.style && (r.style.cssText = s.style), r } _createErrorElement(e) { const t = document.createElement("div"); return t.style.cssText = "color: red; border: 1px solid red; padding: 8px; background: #ffe6e6;", t.textContent = `Component Error: ${e.message}`, t } _replaceWithError(e, t) { const n = this._createErrorElement(t); e.parentNode && e.parentNode.replaceChild(n, e), this.asyncPlaceholders.delete(e) } clearAsyncPropsCache() { this.asyncPropsCache.clear() } getAsyncStats() { return { registeredComponents: this.components.size, cachedAsyncProps: this.asyncPropsCache.size } } } class DOMRenderer { constructor(e) { console.info(log.i("DOMRenderer initialized", { renderMode: "fine-grained" }, "framework")), this.juris = e, this.subscriptions = new WeakMap, this.eventMap = { ondoubleclick: "dblclick", onmousedown: "mousedown", onmouseup: "mouseup", onmouseover: "mouseover", onmouseout: "mouseout", onmousemove: "mousemove", onkeydown: "keydown", onkeyup: "keyup", onkeypress: "keypress", onfocus: "focus", onblur: "blur", onchange: "change", oninput: "input", onsubmit: "submit", onload: "load", onresize: "resize", onscroll: "scroll" }, this.elementCache = new Map, this.recyclePool = new Map, this.renderMode = "fine-grained", this.failureCount = 0, this.maxFailures = 3, this.asyncCache = new Map, this.asyncPlaceholders = new WeakMap, this.placeholderConfigs = new Map, this.defaultPlaceholder = { className: "juris-async-loading", style: "padding: 8px; background: #f0f0f0; border: 1px dashed #ccc; opacity: 0.7;", text: "Loading...", children: null }, this.SVG_ELEMENTS = new Set(["svg", "g", "defs", "desc", "metadata", "title", "circle", "ellipse", "line", "polygon", "polyline", "rect", "path", "text", "tspan", "textPath", "marker", "pattern", "clipPath", "mask", "image", "switch", "foreignObject", "linearGradient", "radialGradient", "stop", "animate", "animateMotion", "animateTransform", "set", "use", "symbol"]) } setRenderMode(e) { ["fine-grained", "batch"].includes(e) ? (this.renderMode = e, console.info(log.i("Render mode changed", { mode: e }, "framework"))) : console.warn(log.w("Invalid render mode", { mode: e }, "application")) } getRenderMode() { return this.renderMode } isFineGrained() { return "fine-grained" === this.renderMode } isBatchMode() { return "batch" === this.renderMode } render(e) { if (console.debug(log.d("Render started", { vnodeType: typeof e, isArray: Array.isArray(e) }, "framework")), !e || "object" != typeof e) return null; if (Array.isArray(e)) { const t = document.createDocumentFragment(); return e.forEach((e => { const n = this.render(e); n && t.appendChild(n) })), t } const t = Object.keys(e)[0], n = e[t] || {}; if (this.juris.componentManager.components.has(t)) { const e = this.juris.stateManager.currentTracking; this.juris.stateManager.currentTracking = null; const s = this.juris.componentManager.create(t, n); return this.juris.stateManager.currentTracking = e, s } if ("string" != typeof t || 0 === t.length) return null; if ("fine-grained" === this.renderMode) return this._createElementFineGrained(t, n); try { const e = n.key || this._generateKey(t, n), s = this.elementCache.get(e); return s && this._canReuseElement(s, t, n) ? (this._updateElementProperties(s, n), s) : this._createElementOptimized(t, n, e) } catch (e) { return this.failureCount++, this.failureCount >= this.maxFailures && (this.renderMode = "fine-grained"), this._createElementFineGrained(t, n) } } _createElementFineGrained(e, t) { console.debug(log.d("Creating element (fine-grained)", { tagName: e, propsCount: Object.keys(t).length }, "framework")); const n = this.SVG_ELEMENTS.has(e.toLowerCase()) ? document.createElementNS("http://www.w3.org/2000/svg", e) : document.createElement(e), s = [], r = []; return Object.entries(t).forEach((([e, t]) => { "children" === e ? this._handleChildren(n, t, s) : "text" === e ? this._handleText(n, t, s) : "style" === e ? this._handleStyle(n, t, s) : e.startsWith("on") ? this._handleEvent(n, e, t, r) : "function" == typeof t ? this._handleReactiveAttribute(n, e, t, s) : this._isPromiseLike(t) ? this._handleAsyncProp(n, e, t, s) : "key" !== e && this._setStaticAttribute(n, e, t) })), (s.length > 0 || r.length > 0) && this.subscriptions.set(n, { subscriptions: s, eventListeners: r }), n } _handleAsyncProp(e, t, n, s) { "text" === t ? this._handleAsyncTextDirect(e, n) : "children" === t ? this._handleAsyncChildrenDirect(e, n) : "style" === t ? this._handleAsyncStyleDirect(e, n) : "innerHTML" === t ? this._handleAsyncInnerHTMLDirect(e, n) : (this._setPlaceholder(e, t), promisify(n).then((n => { const s = this._getPlaceholderConfig(e); e.classList.remove(s.className), this._setStaticAttribute(e, t, n) })).catch((n => { console.error(log.e(`Async prop '${t}' failed:`, n), "application"), this._setErrorState(e, t, n.message) }))) } _handleAsyncInnerHTMLDirect(e, t) { const n = this._getPlaceholderConfig(e); e.innerHTML = `<span class="${n.className}">${n.text}</span>`, promisify(t).then((t => { e.innerHTML = t })).catch((t => { console.error(log.e("Async innerHTML failed:", t), "application"), e.innerHTML = `<span class="juris-async-error">Error: ${t.message}</span>` })) } _hasAsyncProps(e) { return Object.entries(e).some((([e, t]) => !e.startsWith("on") && this._isPromiseLike(t))) } _isPromiseLike(e) { return e?.then } _setupSyncElement(e, t, n, s) { Object.entries(t).forEach((([t, r]) => { "children" === t ? this._handleChildren(e, r, n) : "text" === t ? this._handleText(e, r, n) : "style" === t ? this._handleStyle(e, r, n) : t.startsWith("on") ? this._handleEvent(e, t, r, s) : "function" == typeof r ? this._handleReactiveAttribute(e, t, r, n) : "key" !== t && this._setStaticAttribute(e, t, r) })) } _getPlaceholderConfig(e) { if (e?.id && this.placeholderConfigs.has(e.id)) return this.placeholderConfigs.get(e.id); let t = e?.parentElement; for (; t;) { if (t.id && this.placeholderConfigs.has(t.id)) return this.placeholderConfigs.get(t.id); t = t.parentElement } return this.defaultPlaceholder } _setPlaceholder(e, t) { const n = this._getPlaceholderConfig(e); ({ text: () => { e.textContent = n.text, e.className = n.className, n.style && (e.style.cssText = n.style) }, children: () => { if (n.children) { const t = this.render(n.children); if (t) return void e.appendChild(t) } const t = document.createElement("span"); t.textContent = n.text, t.className = n.className, n.style && (t.style.cssText = n.style), e.appendChild(t) }, className: () => e.classList.add(n.className), style: () => { n.style && (e.style.cssText = n.style), e.classList.add(n.className) } }[t] || (() => { e.setAttribute(t, "loading"), e.classList.add(n.className) }))() } _setErrorState(e, t, n) { e.classList.add("juris-async-error"), "text" === t ? e.textContent = `Error: ${n}` : "children" === t && (e.innerHTML = `<span class="juris-async-error">Error: ${n}</span>`) } _handleChildren(e, t, n) { "fine-grained" === this.renderMode ? this._handleChildrenFineGrained(e, t, n) : this._handleChildrenOptimized(e, t, n) } _handleChildrenFineGrained(e, t, n) { "function" == typeof t ? this._handleReactiveChildren(e, t, n) : this._isPromiseLike(t) ? this._handleAsyncChildrenDirect(e, t) : this._updateChildren(e, t) } _handleChildrenOptimized(e, t, n) { if ("function" == typeof t) { let s = null, r = [], i = !0; const updateChildren = () => { try { const n = t(e); if (this._isPromiseLike(n)) promisify(n).then((t => { if ("ignore" !== t && !this._childrenEqual(s, t)) if (i) try { r = this._reconcileChildren(e, r, t), s = t } catch (n) { console.warn(log.w("Reconciliation failed, falling back to safe rendering:", n.message), "framework"), i = !1, this._updateChildren(e, t), s = t } else this._updateChildren(e, t), s = t })).catch((e => { console.error(log.e("Error in async children function:", e), "framework"), i = !1 })); else if ("ignore" !== n && !this._childrenEqual(s, n)) if (i) try { r = this._reconcileChildren(e, r, n), s = n } catch (t) { console.warn(log.w("Reconciliation failed, falling back to safe rendering:", t.message), "framework"), i = !1, this._updateChildren(e, n), s = n } else this._updateChildren(e, n), s = n } catch (t) { console.error(log.e("Error in children function:", t), "application"), i = !1; try { this._updateChildren(e, []) } catch (e) { console.error(log.e("Even safe fallback failed:", e), "application") } } }; this._createReactiveUpdate(e, updateChildren, n); try { const n = t(); this._isPromiseLike(n) ? promisify(n).then((t => { r = this._reconcileChildren(e, [], t), s = t })).catch((t => { console.warn(log.w("Initial async children failed, using safe method:", t.message), "framework"), i = !1, this._updateChildren(e, []) })) : (r = this._reconcileChildren(e, [], n), s = n) } catch (n) { console.warn(log.w("Initial reconciliation failed, using safe method:", n.message), "framework"), i = !1; const r = t(); this._updateChildren(e, r), s = r } } else if (this._isPromiseLike(t)) this._handleAsyncChildrenDirect(e, t); else try { this._reconcileChildren(e, [], t) } catch (n) { console.warn(log.w("Static reconciliation failed, using safe method:", n.message), "framework"), this._updateChildren(e, t) } } _childrenEqual(e, t) { return deepEquals && deepEquals(e, t) } _reconcileChildren(e, t, n) { console.debug(log.d("Reconciling children", { parentTag: e.tagName, oldCount: t.length, newCount: Array.isArray(n) ? n.length : n ? 1 : 0 }, "framework")), Array.isArray(n) || (n = n ? [n] : []); const s = [], r = document.createDocumentFragment(), i = new Map; t.forEach(((e, t) => { const n = e._jurisKey || `auto-${t}`; i.set(n, e) })); const o = new Set; n.forEach(((t, n) => { if (!t || "object" != typeof t) return; const a = Object.keys(t)[0], c = t[a] || {}, l = c.key || this._generateKey(a, c), h = i.get(l); if (h && !o.has(h) && this._canReuseElement(h, a, c) && !this._wouldCreateCircularReference(e, h)) h.parentNode && h.parentNode.removeChild(h), this._updateElementProperties(h, c), s.push(h), r.appendChild(h), o.add(h), i.delete(l); else { const n = this.render(t); n && !this._wouldCreateCircularReference(e, n) && (n._jurisKey = l, s.push(n), r.appendChild(n)) } })), i.forEach((e => { o.has(e) || this._recycleElement(e) })); try { e.textContent = "", r.hasChildNodes() && e.appendChild(r) } catch (t) { console.error(log.e("Error in reconcileChildren:", t), "framework"), e.textContent = "", s.forEach((t => { try { t && !this._wouldCreateCircularReference(e, t) && e.appendChild(t) } catch (t) { console.error(log.e("Reconciliation failed", { parentTag: e.tagName, error: t.message }, "framework")) } })) } return s } _wouldCreateCircularReference(e, t) { if (!e || !t) return !1; if (e === t) return !0; try { let n = e.parentNode; for (; n;) { if (n === t) return !0; n = n.parentNode } if (t.contains && t.contains(e)) return !0; if (t.children) for (let n of t.children) if (this._wouldCreateCircularReference(e, n)) return !0 } catch (e) { return console.warn(log.w("Error checking circular reference, assuming unsafe:", e), "application"), !0 } return !1 } _recycleElement(e) { if (!e || !e.tagName) return; const t = e.tagName.toLowerCase(); e.parentNode && e.parentNode.removeChild(e), this.recyclePool.has(t) || this.recyclePool.set(t, []); const n = this.recyclePool.get(t); n.length < 100 && (this.cleanup(e), this._resetElement(e), n.push(e)) } _handleAsyncChildrenDirect(e, t) { const n = this._getPlaceholderConfig(e); let s; n.children ? s = this.render(n.children) : (s = document.createElement("div"), s.className = n.className, s.textContent = n.text, n.style && (s.style.cssText = n.style)), e.appendChild(s), this.asyncPlaceholders.set(e, { type: "children", placeholder: s }), promisify(t).then((t => { s.parentNode && e.removeChild(s), this._updateChildren(e, t), this.asyncPlaceholders.delete(e) })).catch((e => { console.error(log.e("Async children failed:", e), "application"), s.textContent = `Error loading content: ${e.message}`, s.className = "juris-async-error" })) } _handleReactiveChildren(e, t, n) { let s = null, r = !1; this._createReactiveUpdate(e, (() => { try { const n = t(e); this._isPromiseLike(n) ? promisify(n).then((t => { "ignore" === t || r && deepEquals(t, s) || (this._updateChildren(e, t), s = t, r = !0) })).catch((e => console.error(log.e("Error in async reactive children:", e), "application"))) : "ignore" === n || r && deepEquals(n, s) || (this._updateChildren(e, n), s = n, r = !0) } catch (e) { console.error(log.e("Error in reactive children function:", e), "application") } }), n) } _updateChildren(e, t) { if ("ignore" === t) return; Array.from(e.children).forEach((e => this.cleanup(e))), e.textContent = ""; const n = document.createDocumentFragment(); if (Array.isArray(t)) t.forEach((e => { const t = this.render(e); t && n.appendChild(t) })); else if (t) { const e = this.render(t); e && n.appendChild(e) } n.hasChildNodes() && e.appendChild(n) } _handleText(e, t, n) { "function" == typeof t ? this._handleReactiveText(e, t, n) : this._isPromiseLike(t) ? this._handleAsyncTextDirect(e, t) : e.textContent = t } _handleAsyncTextDirect(e, t) { const n = this._getPlaceholderConfig(e); e.textContent = n.text, e.className = n.className, n.style && (e.style.cssText = n.style), promisify(t).then((t => { e.textContent = t, e.classList.remove(n.className), n.style && (e.style.cssText = "") })).catch((t => { console.error(log.e("Async text failed:", t), "application"), e.textContent = `Error: ${t.message}`, e.classList.add("juris-async-error") })) } _handleReactiveText(e, t, n) { let s = null, r = !1; this._createReactiveUpdate(e, (() => { try { const n = t(e); this._isPromiseLike(n) ? promisify(n).then((t => { r && t === s || (e.textContent = t, s = t, r = !0) })).catch((e => console.error(log.e("Error in async reactive text:", e), "application"))) : r && n === s || (e.textContent = n, s = n, r = !0) } catch (e) { console.error(log.e("Error in reactive text function:", e), "application") } }), n) } _handleStyle(e, t, n) { "function" == typeof t ? this._handleReactiveStyle(e, t, n) : this._isPromiseLike(t) ? this._handleAsyncStyleDirect(e, t) : "object" == typeof t && Object.entries(t).forEach((([t, s]) => { "function" == typeof s ? this._handleReactiveStyleProperty(e, t, s, n) : e.style[t] = s })) } _handleReactiveStyleProperty(e, t, n, s) { let r = null, i = !1; this._createReactiveUpdate(e, (() => { try { const s = n(e); this._isPromiseLike(s) ? promisify(s).then((n => { i && n === r || (e.style[t] = n, r = n, i = !0) })).catch((e => console.error(`Error in async reactive style property '${t}':`, e))) : i && s === r || (e.style[t] = s, r = s, i = !0) } catch (e) { console.error(`Error in reactive style property '${t}':`, e) } }), s) } _handleAsyncStyleDirect(e, t) { const n = this._getPlaceholderConfig(e); if (e.classList.add(n.className), n.style) { n.style.split(";").filter((e => e.trim())).forEach((t => { const [n, s] = t.split(":").map((e => e.trim())); n && s && (e.style[n] = s) })) } promisify(t).then((t => { if (e.classList.remove(n.className), "object" == typeof t) { if (n.style) { n.style.split(";").map((e => e.split(":")[0].trim())).filter((e => e)).forEach((t => e.style.removeProperty(t))) } Object.assign(e.style, t) } })).catch((e => console.error(log.e("Async style failed:", e), "application"))) } _handleReactiveStyle(e, t, n) { let s = null, r = !1; this._createReactiveUpdate(e, (() => { try { const n = t(e); this._isPromiseLike(n) ? promisify(n).then((t => { r && deepEquals(t, s) || "object" == typeof t && (Object.assign(e.style, t), s = { ...t }, r = !0) })).catch((e => console.error(log.e("Error in async reactive style:", e), "application"))) : r && deepEquals(n, s) || "object" == typeof n && (Object.assign(e.style, n), s = { ...n }, r = !0) } catch (e) { console.error(log.e("Error in reactive style function:", e), "application") } }), n) } _createElementOptimized(e, t, n) { let s = this._getRecycledElement(e); s || (s = this.SVG_ELEMENTS.has(e.toLowerCase()) ? document.createElementNS("http://www.w3.org/2000/svg", e) : document.createElement(e)), n && (this.elementCache.set(n, s), s._jurisKey = n); const r = [], i = []; return this._processProperties(s, t, r, i), (r.length > 0 || i.length > 0) && this.subscriptions.set(s, { subscriptions: r, eventListeners: i }), s } _processProperties(e, t, n, s) { Object.keys(t).forEach((r => { const i = t[r]; "children" === r ? this._handleChildren(e, i, n) : "text" === r ? this._handleText(e, i, n) : "innerHTML" === r ? "function" == typeof i ? this._handleReactiveAttribute(e, r, i, n) : e.innerHTML = i : "style" === r ? this._handleStyle(e, i, n) : r.startsWith("on") ? this._handleEvent(e, r, i, s) : "function" == typeof i ? this._handleReactiveAttribute(e, r, i, n) : "key" !== r && this._setStaticAttribute(e, r, i) })) } _handleEvent(e, t, n, s) { if (console.debug(log.d("Event handler attached", { tagName: e.tagName, eventName: t }, "framework")), "onclick" === t) { e.style.touchAction = "manipulation", e.style.webkitTapHighlightColor = "transparent", e.style.webkitTouchCallout = "none", e.addEventListener("click", n), s.push({ eventName: "click", handler: n }); let t = 0, r = !1, i = 0, o = 0; const touchStart = e => { t = Date.now(), r = !1, e.touches?.[0] && (i = e.touches[0].clientX, o = e.touches[0].clientY) }, touchMove = e => { if (e.touches?.[0]) { const t = Math.abs(e.touches[0].clientX - i), n = Math.abs(e.touches[0].clientY - o); (t > 10 || n > 10) && (r = !0) } }, touchEnd = e => { const s = Date.now() - t; !r && s < 300 && (e.preventDefault(), e.stopPropagation(), n(e)) }; e.addEventListener("touchstart", touchStart, { passive: !0 }), e.addEventListener("touchmove", touchMove, { passive: !0 }), e.addEventListener("touchend", touchEnd, { passive: !1 }), s.push({ eventName: "touchstart", handler: touchStart }, { eventName: "touchmove", handler: touchMove }, { eventName: "touchend", handler: touchEnd }) } else { const r = this.eventMap[t.toLowerCase()] || t.slice(2).toLowerCase(); e.addEventListener(r, n), s.push({ eventName: r, handler: n }) } } _handleReactiveAttribute(e, t, n, s) { let r = null, i = !1; this._createReactiveUpdate(e, (() => { try { const s = n(e); this._isPromiseLike(s) ? promisify(s).then((n => { i && deepEquals(n, r) || (this._setStaticAttribute(e, t, n), r = n, i = !0) })).catch((e => console.error(log.e(`Error in async reactive attribute '${t}':`, e), "application"))) : i && deepEquals(s, r) || (this._setStaticAttribute(e, t, s), r = s, i = !0) } catch (e) { console.error(log.e(`Error in reactive attribute '${t}':`, e), "application") } }), s) } _setStaticAttribute(e, t, n) { if (["children", "key"].includes(t)) return; if ("function" == typeof n) return "value" === t && ["INPUT", "TEXTAREA", "SELECT"].includes(e.tagName) ? void (e.value = n(e)) : void console.warn(log.w(`Function value for attribute '${t}' should be handled reactively`), "application"); if (new Set(["viewBox", "preserveAspectRatio", "textLength", "gradientUnits", "gradientTransform", "spreadMethod", "patternUnits", "patternContentUnits", "patternTransform", "clipPath", "crossOrigin", "xmlns", "xmlns:xlink", "xlink:href"]).has(t) || t.includes("-") || t.includes(":")) e.setAttribute(t, n); else if ("className" === t) e.className = n; else if ("htmlFor" === t) e.setAttribute("for", n); else if ("tabIndex" === t) e.tabIndex = n; else if (t.startsWith("data-") || t.startsWith("aria-")) e.setAttribute(t, n); else if (t in e && "function" != typeof e[t]) try { const s = Object.getOwnPropertyDescriptor(e, t) || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(e), t); s && !1 === s.writable ? e.setAttribute(t, n) : e[t] = n } catch (s) { e.setAttribute(t, n) } else e.setAttribute(t, n) } _createReactiveUpdate(e, t, n) { const s = this.juris.stateManager.startTracking(), r = this.juris.stateManager.currentTracking; this.juris.stateManager.currentTracking = s; try { t(e) } catch (e) { console.error(log.e("Error capturing dependencies:", e), "application") } finally { this.juris.stateManager.currentTracking = r } s.forEach((e => { const s = this.juris.stateManager.subscribeInternal(e, t); n.push(s) })) } updateElementContent(e, t) { this._updateChildren(e, [t]) } setupIndicators(e, t) { this.placeholderConfigs.set(e, { ...this.defaultPlaceholder, ...t }) } cleanup(e) { console.debug(log.d("Cleaning up element", { tagName: e.tagName, hasSubscriptions: this.subscriptions.has(e) }, "framework")), this.juris.componentManager.cleanup(e); const t = this.subscriptions.get(e); t && (t.subscriptions?.forEach((e => { try { e() } catch (e) { console.warn(log.w("Error during subscription cleanup:", e), "application") } })), t.eventListeners?.forEach((({ eventName: t, handler: n }) => { try { e.removeEventListener(t, n) } catch (e) { console.warn(log.w("Error during event listener cleanup:", e), "application") } })), this.subscriptions.delete(e)), e._jurisKey && this.elementCache.delete(e._jurisKey), this.asyncPlaceholders.has(e) && this.asyncPlaceholders.delete(e); try { Array.from(e.children || []).forEach((e => { try { this.cleanup(e) } catch (e) { console.warn(log.w("Error cleaning up child element:", e), "application") } })) } catch (e) { console.warn(log.w("Error during children cleanup:", e), "application") } } _generateKey(e, t) { if (t.key) return t.key; const n = [e];["id", "className", "text"].forEach((e => { t[e] && "function" != typeof t[e] && n.push(`${e}:${t[e]}`) })); const s = this._hashProps(t); return n.push(`hash:${s}`), n.join("|") } _hashProps(e) { const t = JSON.stringify(e, ((e, t) => "function" == typeof t ? "[function]" : t)); let n = 0; for (let e = 0; e < t.length; e++) { n = (n << 5) - n + t.charCodeAt(e), n &= n } return Math.abs(n).toString(36) } _getRecycledElement(e) { const t = this.recyclePool.get(e); if (t?.length > 0) { const e = t.pop(); return this._resetElement(e), e } return null } _resetElement(e) { e.textContent = "", e.className = "", e.removeAttribute("style"); const t = ["id", "data-juris-key"]; Array.from(e.attributes).forEach((n => { t.includes(n.name) || e.removeAttribute(n.name) })) } _canReuseElement(e, t, n) { return e.tagName.toLowerCase() === t.toLowerCase() } _updateElementProperties(e, t) { Object.keys(t).forEach((n => { if (!["key", "children", "text", "style"].includes(n)) { const s = t[n]; "function" != typeof s && this._setStaticAttribute(e, n, s) } })) } clearAsyncCache() { this.asyncCache.clear() } getAsyncStats() { return { cachedAsyncProps: this.asyncCache.size } } } class TemplateCompiler { parseTemplate(e) { const t = e.getAttribute("data-component"), n = e.getAttribute("data-context"), s = e.content, r = s.querySelector("script")?.textContent.trim() || "", i = document.createElement("div"); i.appendChild(s.cloneNode(!0)), i.querySelector("script")?.remove(); return { name: t, script: r, html: i.innerHTML.trim(), contextConfig: n } } htmlToObject(e) { const t = document.createElement("div"); return t.innerHTML = e, this.convertElement(t.firstElementChild) } convertElement(e) { const t = {}, n = e.tagName.toLowerCase(); t[n] = {}; for (const s of e.attributes) { let e = s.value; if (e.startsWith("{") && e.endsWith("}")) { const r = e.slice(1, -1); t[n][s.name] = { __FUNCTION__: r } } else t[n][s.name] = e } const s = Array.from(e.childNodes).map((e => this.convertNode(e))).filter((e => null !== e)); if (1 === s.length) { const e = s[0]; e && e.__REACTIVE_CHILDREN__ ? t[n].children = { __FUNCTION__: e.__REACTIVE_CHILDREN__ } : e && e.__REACTIVE_TEXT__ ? t[n].text = { __FUNCTION__: e.__REACTIVE_TEXT__ } : "string" == typeof e ? t[n].text = e : e && (t[n].children = [e]) } else s.length > 0 && (t[n].children = s); return t } convertNode(e) { if (e.nodeType === Node.TEXT_NODE) { const t = e.textContent.trim(); if (!t) return null; const n = t.match(/^\{children:(.+)\}$/s); if (n) return { __REACTIVE_CHILDREN__: n[1] }; const s = t.match(/^\{text:(.+)\}$/s); if (s) return { __REACTIVE_TEXT__: s[1] }; const r = t.match(/^\{(.+)\}$/s); return r ? { __REACTIVE_TEXT__: r[1] } : t } return e.nodeType === Node.ELEMENT_NODE ? this.convertElement(e) : null } generateContextDestructuring(e) { if (!e) return ""; return `const { ${e.split(",").map((e => e.trim())).join(", ")} } = context;` } generateComponent(e) { const t = this.objectToString(this.htmlToObject(e.html)), n = this.generateContextDestructuring(e.contextConfig); return `(props, context) => {\n${n ? `${n}\n${e.script}` : e.script}\n  return ${t};\n}` } objectToString(e, t = 0) { const n = "  ".repeat(t); if (e && e.__FUNCTION__) return e.__FUNCTION__; if ("string" == typeof e) return `'${e.replace(/'/g, "\\'")}'`; if ("number" == typeof e || "boolean" == typeof e) return String(e); if (Array.isArray(e)) { if (0 === e.length) return "[]"; return "[\n" + e.map((e => n + "  " + this.objectToString(e, t + 1))).join(",\n") + "\n" + n + "]" } if ("object" == typeof e && null !== e) { const s = Object.keys(e); if (0 === s.length) return "{}"; return "{\n" + s.map((s => { const r = this.objectToString(e[s], t + 1), i = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(s) ? s : `'${s}'`; return n + "  " + i + ": " + r })).join(",\n") + "\n" + n + "}" } return "null" } } class DOMEnhancer { constructor(e) { console.info(log.i("DOMEnhancer initialized", {}, "framework")), this.juris = e, this.enhancedElements = new WeakSet, this.containerEnhancements = new WeakMap, this.options = { debounceMs: 5, batchUpdates: !0, observeSubtree: !0, observeChildList: !0, observeNewElements: !0 }, this.enhancementRegistry = new Map, this.unifiedObserver = null, this.observerRefCount = 0, this.pendingEnhancements = new Set, this.enhancementTimer = null } enhance(e, t, n = {}) { if (e instanceof Element) return this.enhancedElements.has(e) ? () => { } : (this._enhanceElement(e, t, { ...this.options, ...n }), () => this._cleanupElement(e)); const s = { ...this.options, ...n }, r = e, i = this._determineEnhancementType(r, t); return console.info(log.i("Enhancement registered", { selector: r, type: i, hasSelectors: "selectors" === i, optionKeys: Object.keys(n) }, "framework")), this.enhancementRegistry.set(r, { definition: t, config: s, type: i }), this._enhanceExistingElements(r, t, s, i), !1 !== s.observeNewElements && (this._ensureUnifiedObserver(s), this.observerRefCount++), () => this._unenhance(r) } _determineEnhancementType(e, t) { return this._hasSelectorsCategory(t) ? "selectors" : "string" == typeof e && /^#[a-zA-Z][\w-]*$/.test(e) ? "id" : "simple" } _hasSelectorsCategory(e) { if (e?.selectors) return !0; if ("function" == typeof e) try { const t = e(this.juris.createContext()); return t?.selectors } catch (e) { return !1 } return !1 } _enhanceExistingElements(e, t, n, s) { if ("selectors" === s) this._enhanceExistingContainers(e, t, n); else { const s = document.querySelectorAll(e); n.batchUpdates && s.length > 1 ? this._batchEnhanceElements(Array.from(s), t, n) : s.forEach((e => this._enhanceElement(e, t, n))) } } _enhanceExistingContainers(e, t, n) { document.querySelectorAll(e).forEach((e => this._enhanceContainer(e, t, n))) } _batchEnhanceElements(e, t, n) { e.filter((e => !this.enhancedElements.has(e))).forEach((e => this._enhanceElement(e, t, n))) } _ensureUnifiedObserver(e) { this.unifiedObserver || (this.unifiedObserver = new MutationObserver((t => { e.debounceMs > 0 ? this._debouncedProcessMutations(t) : this._processUnifiedMutations(t) })), this.unifiedObserver.observe(document.body, { childList: e.observeChildList, subtree: e.observeSubtree })) } _processUnifiedMutations(e) { e.forEach((e => { "childList" === e.type && e.addedNodes.forEach((e => { e.nodeType === Node.ELEMENT_NODE && this._processNodeForAllEnhancements(e) })) })) } _processNodeForAllEnhancements(e) { this.enhancementRegistry.forEach((({ definition: t, config: n, type: s }, r) => { try { switch (s) { case "id": this._processIdEnhancement(e, r, t, n); break; case "simple": this._processSimpleEnhancement(e, r, t, n); break; case "selectors": this._processSelectorsEnhancement(e, r, t, n) } } catch (e) { console.error(log.e("Error processing enhancement:", e), "framework") } })) } _processIdEnhancement(e, t, n, s) { const r = t.slice(1); if (e.id === r) this._enhanceElement(e, n, s); else if (e.querySelector) { const r = e.querySelector(t); r && this._enhanceElement(r, n, s) } } _processSimpleEnhancement(e, t, n, s) { e.matches && e.matches(t) && this._enhanceElement(e, n, s), e.querySelectorAll && e.querySelectorAll(t).forEach((e => { this._enhanceElement(e, n, s) })) } _processSelectorsEnhancement(e, t, n, s) { e.matches && e.matches(t) && this._enhanceContainer(e, n, s), e.querySelectorAll && e.querySelectorAll(t).forEach((e => { this._enhanceContainer(e, n, s) })), this._enhanceNewElementsInContainers(e) } _debouncedProcessMutations(e) { e.forEach((e => { "childList" === e.type && e.addedNodes.forEach((e => { e.nodeType === Node.ELEMENT_NODE && this.pendingEnhancements.add({ node: e, timestamp: Date.now(), type: "unified" }) })) })), this.enhancementTimer && clearTimeout(this.enhancementTimer), this.enhancementTimer = setTimeout((() => { this._processPendingEnhancements(), this.enhancementTimer = null }), this.options.debounceMs) } _processPendingEnhancements() { const e = Array.from(this.pendingEnhancements); this.pendingEnhancements.clear(), e.forEach((({ node: e }) => { this._processNodeForAllEnhancements(e) })) } _enhanceNewElementsInContainers(e) { document.querySelectorAll("[data-juris-enhanced-container]").forEach((t => { if (!t.contains(e)) return; const n = this.containerEnhancements.get(t); n && n.forEach(((n, s) => { const { definition: r, enhancedElements: i } = n; e.matches && e.matches(s) && (this._enhanceSelectorElement(e, r, t, s), i.add(e)), e.querySelectorAll && e.querySelectorAll(s).forEach((e => { this.enhancedElements.has(e) || (this._enhanceSelectorElement(e, r, t, s), i.add(e)) })) })) })) } _enhanceContainer(e, t, n) { if (!this.enhancedElements.has(e)) try { this.enhancedElements.add(e), e.setAttribute("data-juris-enhanced-container", Date.now()); let s = t; if ("function" == typeof t) { s = t(this.juris.createContext(e)) } if (!s?.selectors) return void console.warn(log.w('Selectors enhancement must have a "selectors" property'), "framework"); const r = new Map; this.containerEnhancements.set(e, r), this._applyContainerProperties(e, s), Object.entries(s.selectors).forEach((([t, s]) => { this._enhanceSelector(e, t, s, r, n) })) } catch (t) { console.error(log.e("Error enhancing container:", t), "application"), this.enhancedElements.delete(e) } } _applyContainerProperties(e, t) { const n = { ...t }; delete n.selectors, Object.keys(n).length > 0 && this._applyEnhancements(e, n) } _enhanceSelector(e, t, n, s, r) { const i = e.querySelectorAll(t), o = new Set; i.forEach((s => { this.enhancedElements.has(s) || (this._enhanceSelectorElement(s, n, e, t), o.add(s)) })), s.set(t, { definition: n, enhancedElements: o }) } _enhanceSelectorElement(e, t, n, s) { try { this.enhancedElements.add(e), e.setAttribute("data-juris-enhanced-selector", Date.now()); let n = t; if ("function" == typeof t) { if (n = t(this.juris.createContext(e)), !n || "object" != typeof n) return console.warn(log.w(`Selector '${s}' function must return a definition object`), "framework"), void this.enhancedElements.delete(e) } const r = this._processElementAwareFunctions(e, n); this._applyEnhancements(e, r) } catch (t) { console.error(log.e("Error enhancing selector element:", t), "application"), this.enhancedElements.delete(e) } } _processElementAwareFunctions(e, t) { const n = {}; return Object.entries(t).forEach((([t, s]) => { if ("function" == typeof s) if (t.startsWith("on")) n[t] = s; else if (s.length > 0) try { const r = s(this.juris.createContext(e)); n[t] = r && "object" == typeof r ? r : s } catch (e) { console.warn(log.w(`Error processing element-aware function '${t}':`, e), "framework"), n[t] = s } else n[t] = s; else n[t] = s })), n } _enhanceElement(e, t, n) { if (this.enhancedElements.has(e)) console.debug(log.d("Element already enhanced", { tagName: e.tagName }, "framework")); else try { console.debug(log.d("Enhancing element", { tagName: e.tagName, definitionKeys: Object.keys(t) }, "framework")), this.enhancedElements.add(e), e.setAttribute("data-juris-enhanced", Date.now()); let s = t; if ("function" == typeof t) { if (s = t(this.juris.createContext(e)), !s || "object" != typeof s) return console.warn(log.w("Enhancement function must return a definition object"), "framework"), void this.enhancedElements.delete(e) } this._applyEnhancements(e, s), n.onEnhanced?.(e, this.juris.createContext(e)) } catch (t) { console.error(log.e("Element enhancement failed", { tagName: e.tagName, error: t.message }, "framework")), this.enhancedElements.delete(e) } } _applyEnhancements(e, t) { const n = [], s = [], r = this.juris.domRenderer; Object.keys(t).forEach((i => { const o = t[i]; try { "children" === i ? this._handleChildren(e, o, n, r) : "text" === i ? r._handleText(e, o, n) : "innerHTML" === i ? this._handleInnerHTML(e, o, n, r) : "style" === i ? r._handleStyle(e, o, n) : i.startsWith("on") ? r._handleEvent(e, i, o, s) : "function" == typeof o ? r._handleReactiveAttribute(e, i, o, n) : r._setStaticAttribute(e, i, o) } catch (e) { console.error(log.e(`Error processing enhancement property '${i}':`, e), "framework") } })), (n.length > 0 || s.length > 0) && this.juris.domRenderer.subscriptions.set(e, { subscriptions: n, eventListeners: s }) } _handleChildren(e, t, n, s) { s.isFineGrained() ? s._handleChildrenFineGrained(e, t, n) : s._handleChildrenOptimized(e, t, n) } _handleInnerHTML(e, t, n, s) { "function" == typeof t ? s._handleReactiveAttribute(e, "innerHTML", t, n) : e.innerHTML = t } _unenhance(e) { const t = this.enhancementRegistry.get(e); t && (this.observerRefCount--, 0 === this.observerRefCount && this.unifiedObserver && (this.unifiedObserver.disconnect(), this.unifiedObserver = null), this.enhancementRegistry.delete(e), "selectors" === t.type ? document.querySelectorAll(`${e}[data-juris-enhanced-container]`).forEach((e => { this._cleanupContainer(e) })) : document.querySelectorAll(`${e}[data-juris-enhanced]`).forEach((e => { this._cleanupElement(e) }))) } _cleanupContainer(e) { const t = this.containerEnhancements.get(e); t && (t.forEach((e => { e.enhancedElements.forEach((e => this._cleanupElement(e))) })), this.containerEnhancements.delete(e)), this._cleanupElement(e), e.removeAttribute("data-juris-enhanced-container") } _cleanupElement(e) { this.juris.domRenderer.cleanup(e), this.enhancedElements.delete(e), e.removeAttribute("data-juris-enhanced"), e.removeAttribute("data-juris-enhanced-selector") } configure(e) { Object.assign(this.options, e) } getStats() { const e = document.querySelectorAll("[data-juris-enhanced]").length, t = document.querySelectorAll("[data-juris-enhanced-container]").length, n = document.querySelectorAll("[data-juris-enhanced-selector]").length; return { enhancementRules: this.enhancementRegistry.size, activeObserver: this.unifiedObserver ? 1 : 0, observerRefCount: this.observerRefCount, pendingEnhancements: this.pendingEnhancements.size, enhancedElements: e, enhancedContainers: t, enhancedSelectors: n, totalEnhanced: e + n } } destroy() { this.unifiedObserver && (this.unifiedObserver.disconnect(), this.unifiedObserver = null), this.enhancementRegistry.clear(), this.observerRefCount = 0, this.enhancementTimer && (clearTimeout(this.enhancementTimer), this.enhancementTimer = null), document.querySelectorAll("[data-juris-enhanced], [data-juris-enhanced-selector]").forEach((e => { this._cleanupElement(e) })), document.querySelectorAll("[data-juris-enhanced-container]").forEach((e => { this._cleanupContainer(e) })), this.pendingEnhancements.clear() } } class Juris { constructor(e = {}) { e.logLevel && this.setupLogging(e.logLevel), console.info(log.i("Juris framework initializing", { hasServices: !!e.services, hasLayout: !!e.layout, hasStates: !!e.states, hasComponents: !!e.components, renderMode: e.renderMode || "auto" }, "framework")), this.services = e.services || {}, this.layout = e.layout, this.stateManager = new StateManager(e.states || {}, e.middleware || []), this.headlessManager = new HeadlessManager(this), this.componentManager = new ComponentManager(this), this.domRenderer = new DOMRenderer(this), this.domEnhancer = new DOMEnhancer(this), this.templateCompiler = new TemplateCompiler, this.headlessAPIs = {}, !1 !== e.autoCompileTemplates && this.compileTemplates(), e.headlessComponents && Object.entries(e.headlessComponents).forEach((([e, t]) => { "function" == typeof t ? this.headlessManager.register(e, t) : this.headlessManager.register(e, t.fn, t.options) })), e.placeholders && Object.entries(e.placeholders).forEach((([e, t]) => { this.domRenderer.setupIndicators(e, t) })), e.defaultPlaceholder && (this.domRenderer.defaultPlaceholder = { ...this.domRenderer.defaultPlaceholder, ...e.defaultPlaceholder }), this.headlessManager.initializeQueued(), "fine-grained" === e.renderMode ? this.domRenderer.setRenderMode("fine-grained") : "batch" === e.renderMode && this.domRenderer.setRenderMode("batch"), e.components && Object.entries(e.components).forEach((([e, t]) => { this.componentManager.register(e, t) })), console.info(log.i("Juris framework initialized", { componentsCount: this.componentManager.components.size, headlessCount: this.headlessManager.components.size }, "framework")) } compileTemplates() { const templates = document.querySelectorAll("template[data-component]"), components = {}; templates.forEach((template => { const parsed = this.templateCompiler.parseTemplate(template), componentCode = this.templateCompiler.generateComponent(parsed); components[parsed.name] = eval(`(${componentCode})`) })), Object.entries(components).forEach((([e, t]) => { this.registerComponent(e, t) })) } setupLogging(e) { const t = { debug: 0, info: 1, warn: 2, error: 3 }[e] || 1; t > 0 && (console.debug = () => { }), t > 1 && (console.log("Juris logging initialized at level:", e), console.log('To change log level, use juris.setupLogging("newLevel") or set logLevel in config'), console.log = () => { }, console.info = () => { }) } setupIndicators(e, t) { this.domRenderer.setupIndicators(e, t) } createHeadlessContext(e = null) { const t = { getState: (e, t, n) => this.stateManager.getState(e, t, n), setState: (e, t, n) => this.stateManager.setState(e, t, n), executeBatch: e => this.executeBatch(e), subscribe: (e, t) => this.stateManager.subscribe(e, t), services: this.services, ...this.services || {}, headless: this.headlessManager.context, isSSR: "undefined" == typeof window, ...this.headlessAPIs || {}, components: { register: (e, t) => this.componentManager.register(e, t), registerHeadless: (e, t, n) => this.headlessManager.register(e, t, n), get: e => this.componentManager.components.get(e), getHeadless: e => this.headlessManager.getInstance(e), initHeadless: (e, t) => this.headlessManager.initialize(e, t), reinitHeadless: (e, t) => this.headlessManager.reinitialize(e, t) }, utils: { render: e => this.render(e), cleanup: () => this.cleanup(), forceRender: () => this.render(), getHeadlessStatus: () => this.headlessManager.getStatus() }, setupIndicators: (e, t) => this.setupIndicators(e, t), juris: this, logger: { log: log, lwarn: log.w, error: log.e, info: log.i, debug: log.d, subscribe: logSub, unsubscribe: logUnsub } }; return e && (t.element = e), t } executeBatch(e) { return this.stateManager.executeBatch(e) } createContext(e = null) { const t = { getState: (e, t, n) => this.stateManager.getState(e, t, n), setState: (e, t, n) => this.stateManager.setState(e, t, n), executeBatch: e => this.executeBatch(e), subscribe: (e, t) => this.stateManager.subscribe(e, t), services: this.services, ...this.services || {}, ...this.headlessAPIs || {}, headless: this.headlessManager.context, isSSR: "undefined" == typeof window, components: { register: (e, t) => this.componentManager.register(e, t), registerHeadless: (e, t, n) => this.headlessManager.register(e, t, n), get: e => this.componentManager.components.get(e), getHeadless: e => this.headlessManager.getInstance(e), initHeadless: (e, t) => this.headlessManager.initialize(e, t), reinitHeadless: (e, t) => this.headlessManager.reinitialize(e, t), getHeadlessAPI: e => this.headlessManager.getAPI(e), getAllHeadlessAPIs: () => this.headlessManager.getAllAPIs() }, utils: { render: e => this.render(e), cleanup: () => this.cleanup(), forceRender: () => this.render(), setRenderMode: e => this.setRenderMode(e), getRenderMode: () => this.getRenderMode(), isFineGrained: () => this.isFineGrained(), isBatchMode: () => this.isBatchMode(), getHeadlessStatus: () => this.headlessManager.getStatus() }, setupIndicators: (e, t) => this.setupIndicators(e, t), juris: this, logger: { log: log, lwarn: log.w, error: log.e, info: log.i, debug: log.d, subscribe: logSub, unsubscribe: logUnsub } }; return e && (t.element = e), t } getState(e, t, n) { return this.stateManager.getState(e, t, n) } setState(e, t, n) { return console.debug(log.d("Public setState called", { path: e }, "application")), this.stateManager.setState(e, t, n) } subscribe(e, t, n = !0) { return this.stateManager.subscribe(e, t, n) } subscribeExact(e, t) { return this.stateManager.subscribeExact(e, t) } registerComponent(e, t) { return console.info(log.i("Public component registration", { name: e }, "application")), this.componentManager.register(e, t) } registerHeadlessComponent(e, t, n) { return this.headlessManager.register(e, t, n) } getComponent(e) { return this.componentManager.components.get(e) } getHeadlessComponent(e) { return this.headlessManager.getInstance(e) } initializeHeadlessComponent(e, t) { return this.headlessManager.initialize(e, t) } setRenderMode(e) { this.domRenderer.setRenderMode(e) } getRenderMode() { return this.domRenderer.getRenderMode() } isFineGrained() { return this.domRenderer.isFineGrained() } isBatchMode() { return this.domRenderer.isBatchMode() } _updateComponentContexts() { this.headlessAPIs } registerAndInitHeadless(e, t, n = {}) { return this.headlessManager.register(e, t, n), this.headlessManager.initialize(e, n) } getHeadlessStatus() { return this.headlessManager.getStatus() } objectToHtml(e) { return this.domRenderer.render(e) } render(e = "#app") { const t = performance.now(); console.info(log.i("Render started with template compilation", { container: e }, "application")); const n = "string" == typeof e ? document.querySelector(e) : e; if (!n) return void console.error(log.e("Render container not found", { container: e }, "application")); const s = this.getState("isHydration", !1); try { s ? this._renderWithHydration(n) : this._renderImmediate(n); const e = performance.now() - t; console.info(log.i("Render completed with templates", { duration: `${e.toFixed(2)}ms`, isHydration: s }, "application")) } catch (t) { console.error(log.e("Render failed", { error: t.message, container: e }, "application")), this._renderError(n, t) } } _renderImmediate = function (e) { e.innerHTML = ""; const t = this.domRenderer.render(this.layout); t && e.appendChild(t) }; _renderWithHydration = async function (e) { const t = document.createElement("div"); t.style.cssText = "position: absolute; left: -9999px; visibility: hidden;", document.body.appendChild(t); try { startTracking(); const n = this.domRenderer.render(this.layout); for (n && t.appendChild(n), await onAllComplete(), e.innerHTML = ""; t.firstChild;)e.appendChild(t.firstChild); this.headlessManager.initializeQueued() } finally { stopTracking(), document.body.removeChild(t) } }; _renderError(e, t) { const n = document.createElement("div"); n.style.cssText = "color: red; border: 2px solid red; padding: 16px; margin: 8px; background: #ffe6e6;", n.innerHTML = `\n                <h3>Render Error</h3>\n                <p><strong>Message:</strong> ${t.message}</p>\n                <pre style="background: #f5f5f5; padding: 8px; overflow: auto;">${t.stack || ""}</pre>\n            `, e.appendChild(n) } enhance(e, t, n) { return this.domEnhancer.enhance(e, t, n) } configureEnhancement(e) { return this.domEnhancer.configure(e) } getEnhancementStats() { return this.domEnhancer.getStats() } cleanup() { console.info(log.i("Framework cleanup initiated", {}, "application")), this.headlessManager.cleanup() } destroy() { console.info(log.i("Framework destruction initiated", {}, "application")), this.cleanup(), this.domEnhancer.destroy(), this.stateManager.subscribers.clear(), this.stateManager.externalSubscribers.clear(), this.componentManager.components.clear(), this.headlessManager.components.clear(), console.info(log.i("Framework destroyed", {}, "application")) } } "undefined" != typeof window ? (window.Juris = Juris, window.jurisVersion = jurisVersion, window.jurisLinesOfCode = jurisLinesOfCode, window.jurisMinifiedSize = jurisMinifiedSize) : "undefined" != typeof globalThis && void 0 !== globalThis.module && (globalThis.module.exports = Juris, globalThis.module.exports.jurisVersion = jurisVersion, globalThis.module.exports.jurisLinesOfCode = jurisLinesOfCode, globalThis.module.exports.jurisMinifiedSize = jurisMinifiedSize) })();