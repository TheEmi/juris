!function () { "use strict"; const isValidPath = e => "string" == typeof e && e.trim().length > 0 && !e.includes(".."), getPathParts = e => e.split(".").filter(Boolean), deepEquals = (e, t) => { if (e === t) return !0; if (null == e || null == t || typeof e != typeof t) return !1; if ("object" == typeof e) { if (Array.isArray(e) !== Array.isArray(t)) return !1; const n = Object.keys(e), s = Object.keys(t); return n.length === s.length && n.every((n => s.includes(n) && deepEquals(e[n], t[n]))) } return !1 }, e = "0.76.0", t = "50.61 kB", { log: n, logSub: s, logUnsub: r } = (() => { const e = [], f = (t, n, s) => { const r = `${s ? `[${s}] ` : ""}${t}${n ? ` ${JSON.stringify(n)}` : ""}`; return setTimeout((() => e.forEach((e => e(r, s)))), 0), r }; return { log: { l: f, w: f, e: f, i: f, d: f }, sub: t => e.push(t), unsub: t => e.splice(e.indexOf(t), 1) } })(), { promisify: i, startTracking: o, stopTracking: a, onAllComplete: c } = (() => { const e = new Set; let t = !1; const n = new Set, checkAllComplete = () => { 0 === e.size && n.size > 0 && n.forEach((e => e())) }; return { promisify: n => { const s = n?.then ? n : Promise.resolve(n); return t && s !== n && (e.add(s), s.finally((() => { e.delete(s), setTimeout(checkAllComplete, 0) }))), s }, startTracking: () => { t = !0, e.clear() }, stopTracking: () => { t = !1, n.clear() }, onAllComplete: t => (n.add(t), 0 === e.size && setTimeout(t, 0), () => n.delete(t)) } })(); class StateManager { constructor(e = {}, t = []) { console.info(n.i("StateManager initialized", { initialStateKeys: Object.keys(e), middlewareCount: t.length }, "framework")), this.state = { ...e }, this.middleware = [...t], this.subscribers = new Map, this.externalSubscribers = new Map, this.currentTracking = null, this.isUpdating = !1, this.updateQueue = [], this.batchTimeout = null, this.batchUpdateInProgress = !1, this.maxBatchSize = 50, this.batchDelayMs = 0, this.batchingEnabled = !0, this.initialState = JSON.parse(JSON.stringify(e)), this.maxUpdateDepth = 50, this.updateDepth = 0, this.currentlyUpdating = new Set } reset(e = []) { console.info(n.i("State reset", { preservedPaths: e }, "framework")); const t = {}; e.forEach((e => { const n = this.getState(e); null !== n && (t[e] = n) })), this.state = {}, Object.entries(this.initialState).forEach((([e, t]) => this.setState(e, JSON.parse(JSON.stringify(t))))), Object.entries(t).forEach((([e, t]) => this.setState(e, t))) } getState(e, t = null, n = !0) { if (!isValidPath(e)) return t; n && this.currentTracking?.add(e); const s = getPathParts(e); let r = this.state; for (const e of s) { if (void 0 === r?.[e]) return t; r = r[e] } return r } setState(e, t, s = {}) { console.debug(n.d("State change initiated", { path: e, hasValue: void 0 !== t }, "application")), isValidPath(e) && !this._hasCircularUpdate(e) && (this.batchingEnabled && this.batchDelayMs > 0 ? this._queueUpdate(e, t, s) : this._setStateImmediate(e, t, s)) } _setStateImmediate(e, t, s = {}) { const r = this.getState(e); let i = t; for (const t of this.middleware) try { const n = t({ path: e, oldValue: r, newValue: i, context: s, state: this.state }); void 0 !== n && (i = n) } catch (s) { console.error(n.e("Middleware error", { path: e, error: s.message, middlewareName: t.name || "anonymous" }, "application")) } if (deepEquals(r, i)) return void console.debug(n.d("State unchanged, skipping update", { path: e }, "framework")); console.debug(n.d("State updated", { path: e, oldValue: typeof r, newValue: typeof i }, "application")); const o = getPathParts(e); let a = this.state; for (let e = 0; e < o.length - 1; e++) { const t = o[e]; null != a[t] && "object" == typeof a[t] || (a[t] = {}), a = a[t] } a[o[o.length - 1]] = i, this.isUpdating || (this.isUpdating = !0, this.currentlyUpdating || (this.currentlyUpdating = new Set), this.currentlyUpdating.add(e), this._notifySubscribers(e, i, r), this._notifyExternalSubscribers(e, i, r), this.currentlyUpdating.delete(e), this.isUpdating = !1) } _queueUpdate(e, t, n) { this.updateQueue.push({ path: e, value: t, context: n, timestamp: Date.now() }), this.updateQueue.length > 2 * this.maxBatchSize ? this._processBatchedUpdates() : this.batchTimeout || (this.batchTimeout = setTimeout((() => this._processBatchedUpdates()), this.batchDelayMs)) } _processBatchedUpdates() { if (this.batchUpdateInProgress || 0 === this.updateQueue.length) return; this.batchUpdateInProgress = !0, this.batchTimeout && (clearTimeout(this.batchTimeout), this.batchTimeout = null); const e = Math.min(this.maxBatchSize, this.updateQueue.length), t = this.updateQueue.splice(0, e); try { const e = new Map; t.forEach((t => e.set(t.path, t))), e.forEach((e => this._setStateImmediate(e.path, e.value, e.context))) } catch (e) { console.error(n.e("Error processing batched updates:", e), "framework") } finally { this.batchUpdateInProgress = !1, this.updateQueue.length > 0 && setTimeout((() => this._processBatchedUpdates()), 0) } } configureBatching(e = {}) { this.maxBatchSize = e.maxBatchSize || this.maxBatchSize, this.batchDelayMs = void 0 !== e.batchDelayMs ? e.batchDelayMs : this.batchDelayMs, void 0 !== e.enabled && (this.batchingEnabled = e.enabled) } subscribe(e, t, n = !0) { this.externalSubscribers.has(e) || this.externalSubscribers.set(e, new Set); const s = { callback: t, hierarchical: n }; return this.externalSubscribers.get(e).add(s), () => { const t = this.externalSubscribers.get(e); t && (t.delete(s), 0 === t.size && this.externalSubscribers.delete(e)) } } subscribeExact(e, t) { return this.subscribe(e, t, !1) } subscribeInternal(e, t) { return this.subscribers.has(e) || this.subscribers.set(e, new Set), this.subscribers.get(e).add(t), () => { const n = this.subscribers.get(e); n && (n.delete(t), 0 === n.size && this.subscribers.delete(e)) } } _notifySubscribers(e, t, n) { this._triggerPathSubscribers(e); const s = getPathParts(e); for (let e = s.length - 1; e > 0; e--)this._triggerPathSubscribers(s.slice(0, e).join(".")); const r = e ? e + "." : ""; new Set([...this.subscribers.keys(), ...this.externalSubscribers.keys()]).forEach((t => { t.startsWith(r) && t !== e && this._triggerPathSubscribers(t) })) } _notifyExternalSubscribers(e, t, s) { this.externalSubscribers.forEach(((r, i) => { r.forEach((({ callback: r, hierarchical: o }) => { if (o ? e === i || e.startsWith(i + ".") : e === i) try { r(t, s, e) } catch (e) { console.error(n.e("External subscriber error:", e), "application") } })) })) } _triggerPathSubscribers(e) { const t = this.subscribers.get(e); t && (console.debug(n.d("Triggering subscribers", { path: e, subscriberCount: t.size }, "framework")), new Set(t).forEach((e => { try { const t = this.currentTracking, n = new Set; this.currentTracking = n, e(), this.currentTracking = t, n.forEach((t => { const n = this.subscribers.get(t); n && n.has(e) || this.subscribeInternal(t, e) })) } catch (e) { console.error(n.e("Subscriber error:", e), "application"), this.currentTracking = oldTracking } }))) } _hasCircularUpdate(e) { return this.currentlyUpdating || (this.currentlyUpdating = new Set), !!this.currentlyUpdating.has(e) && (console.warn(n.w("Circular dependency detected", { path: e }, "framework")), !0) } startTracking() { const e = new Set; return this.currentTracking = e, e } endTracking() { const e = this.currentTracking; return this.currentTracking = null, e || new Set } } class HeadlessManager { constructor(e) { console.info(n.i("HeadlessManager initialized", {}, "framework")), this.juris = e, this.components = new Map, this.instances = new Map, this.context = {}, this.initQueue = new Set, this.lifecycleHooks = new Map } register(e, t, s = {}) { console.info(n.i("Headless component registered", { name: e, hasOptions: Object.keys(s).length > 0 }, "framework")), this.components.set(e, { fn: t, options: s }), s.autoInit && this.initQueue.add(e) } initialize(e, t = {}) { console.debug(n.d("Initializing headless component", { name: e, propsKeys: Object.keys(t) }, "framework")); const s = this.components.get(e); if (!s) return console.error(n.e("Headless component not found", { name: e }, "framework")), null; try { const r = this.juris.createHeadlessContext(), i = s.fn(t, r); return i && "object" == typeof i ? (console.info(n.i("Headless component initialized", { name: e, hasAPI: !!i.api, hasHooks: !!i.hooks }, "framework")), this.instances.set(e, i), i.hooks && this.lifecycleHooks.set(e, i.hooks), i.api && (this.context[e] = i.api, this.juris.headlessAPIs || (this.juris.headlessAPIs = {}), this.juris.headlessAPIs[e] = i.api, this.juris._updateComponentContexts()), i.hooks?.onRegister?.(), i) : (console.error(n.e("Invalid headless component instance", { name: e }, "framework")), null) } catch (t) { return console.error(n.e("Headless component initialization failed", { name: e, error: t.message }, "framework")), null } } initializeQueued() { this.initQueue.forEach((e => { if (!this.instances.has(e)) { const t = this.components.get(e); this.initialize(e, t.options || {}) } })), this.initQueue.clear() } getInstance(e) { return this.instances.get(e) } getAPI(e) { return this.context[e] } getAllAPIs() { return { ...this.context } } reinitialize(e, t = {}) { const s = this.instances.get(e); if (s?.hooks?.onUnregister) try { s.hooks.onUnregister() } catch (t) { console.error(n.e(`Error in onUnregister for '${e}':`, t), "framework") } return this.context[e] && delete this.context[e], this.juris.headlessAPIs?.[e] && delete this.juris.headlessAPIs[e], this.instances.delete(e), this.lifecycleHooks.delete(e), this.initialize(e, t) } cleanup() { console.info(n.i("Cleaning up headless components", { instanceCount: this.instances.size }, "framework")), this.instances.forEach(((e, t) => { if (e.hooks?.onUnregister) try { e.hooks.onUnregister() } catch (e) { console.error(n.e(`Error in onUnregister for '${t}':`, e), "framework") } })), this.instances.clear(), this.context = {}, this.lifecycleHooks.clear(), this.juris.headlessAPIs && (this.juris.headlessAPIs = {}) } getStatus() { return { registered: Array.from(this.components.keys()), initialized: Array.from(this.instances.keys()), queued: Array.from(this.initQueue), apis: Object.keys(this.context) } } } class ComponentManager { constructor(e) { console.info(n.i("ComponentManager initialized", {}, "framework")), this.juris = e, this.components = new Map, this.instances = new WeakMap, this.componentCounters = new Map, this.componentStates = new WeakMap, this.asyncPlaceholders = new WeakMap, this.asyncPropsCache = new Map } register(e, t) { console.info(n.i("Component registered", { name: e }, "framework")), this.components.set(e, t) } create(e, t = {}) { const s = this.components.get(e); if (!s) return console.error(n.e("Component not found", { name: e }, "framework")), null; try { if (this._hasAsyncProps(t)) return console.debug(n.d("Component has async props", { name: e }, "framework")), this._createWithAsyncProps(e, s, t); const { componentId: r, componentStates: o } = this._setupComponent(e); console.debug(n.d("Component setup complete", { name: e, componentId: r, stateCount: o.size }, "framework")); const a = s(t, this._createComponentContext(r, o)); return a?.then ? this._handleAsyncComponent(i(a), e, t, o) : this._processComponentResult(a, e, t, o) } catch (t) { return console.error(n.e("Component creation failed", { name: e, error: t.message }, "framework")), this._createErrorElement(t) } } _setupComponent(e) { this.componentCounters.has(e) || this.componentCounters.set(e, 0); const t = this.componentCounters.get(e) + 1; this.componentCounters.set(e, t); return { componentId: `${e}_${t}`, componentStates: new Set } } _createComponentContext(e, t) { const n = this.juris.createContext(); return n.newState = (n, s) => { const r = `__local.${e}.${n}`; return this.juris.stateManager.getState(r, Symbol("not-found")) === Symbol("not-found") && this.juris.stateManager.setState(r, s), t.add(r), [() => this.juris.stateManager.getState(r, s), e => this.juris.stateManager.setState(r, e)] }, n } _hasAsyncProps(e) { return Object.values(e).some((e => e?.then)) } _createWithAsyncProps(e, t, s) { console.debug(n.d("Creating component with async props", { name: e }, "framework")); const r = this._createPlaceholder(`Loading ${e}...`, "juris-async-props-loading"); return this.asyncPlaceholders.set(r, { name: e, props: s, type: "async-props" }), this._resolveAsyncProps(s).then((n => { try { const s = this._createSyncComponent(e, t, n); s && r.parentNode && r.parentNode.replaceChild(s, r), this.asyncPlaceholders.delete(r) } catch (e) { this._replaceWithError(r, e) } })).catch((e => this._replaceWithError(r, e))), r } async _resolveAsyncProps(e) { const t = this._generateCacheKey(e), n = this.asyncPropsCache.get(t); if (n && Date.now() - n.timestamp < 5e3) return n.props; const s = {}; for (const [t, n] of Object.entries(e)) if (n?.then) try { s[t] = await n } catch (e) { s[t] = { __asyncError: e.message } } else s[t] = n; return this.asyncPropsCache.set(t, { props: s, timestamp: Date.now() }), s } _generateCacheKey(e) { return JSON.stringify(e, ((e, t) => t?.then ? "[Promise]" : t)) } _createSyncComponent(e, t, n) { const { componentId: s, componentStates: r } = this._setupComponent(e), o = t(n, this._createComponentContext(s, r)); return o?.then ? this._handleAsyncComponent(i(o), e, n, r) : this._processComponentResult(o, e, n, r) } _handleAsyncComponent(e, t, s, r) { console.debug(n.d("Handling async component", { name: t }, "framework")); const i = this._createPlaceholder(`Loading ${t}...`, "juris-async-loading"); return this.asyncPlaceholders.set(i, { name: t, props: s, componentStates: r }), e.then((e => { console.debug(n.d("Async component resolved", { name: t }, "framework")); try { const n = this._processComponentResult(e, t, s, r); n && i.parentNode && i.parentNode.replaceChild(n, i), this.asyncPlaceholders.delete(i) } catch (e) { console.error(n.e("Async component failed", { name: t, error: e.message }, "framework")), this._replaceWithError(i, e) } })).catch((e => this._replaceWithError(i, e))), i } _processComponentResult(e, t, n, s) { if (e && "object" == typeof e) { if (this._hasLifecycleHooks(e)) return this._createLifecycleComponent(e, t, n, s); if ("function" == typeof e.render && !this._hasLifecycleHooks(e)) { const n = e.render(); if (n?.then) return this._handleAsyncRender(i(n), t, s, e.indicator); const r = this.juris.domRenderer.render(n); return r && s.size > 0 && this.componentStates.set(r, s), r } const r = Object.keys(e); if (1 === r.length && "string" == typeof r[0] && r[0].length > 0) { const t = this.juris.domRenderer.render(e); return t && s.size > 0 && this.componentStates.set(t, s), t } } const r = this.juris.domRenderer.render(e); return r && s.size > 0 && this.componentStates.set(r, s), r } _hasLifecycleHooks(e) { return e.hooks && (e.hooks.onMount || e.hooks.onUpdate || e.hooks.onUnmount) || e.onMount || e.onUpdate || e.onUnmount } _handleAsyncRender(e, t, n, s = null) { const r = s ? this.juris.domRenderer.render(s) : this._createPlaceholder(`Loading ${t}...`, "juris-async-loading"); return e.then((e => { try { const t = this.juris.domRenderer.render(e); t && n.size > 0 && this.componentStates.set(t, n), r.parentNode && r.parentNode.replaceChild(t, r) } catch (e) { this._replaceWithError(r, e) } })).catch((e => this._replaceWithError(r, e))), r } _createLifecycleComponent(e, t, s, r) { const o = { name: t, props: s, hooks: e.hooks || {}, api: e.api || {}, render: e.render }, a = o.render(); if (a?.then) return this._handleAsyncLifecycleRender(i(a), o, r); const c = this.juris.domRenderer.render(a); return c && (this.instances.set(c, o), r?.size > 0 && this.componentStates.set(c, r), o.hooks.onMount && setTimeout((() => { try { const e = o.hooks.onMount(); e?.then && i(e).catch((e => console.error(n.e(`Async onMount error in ${t}:`, e), "application"))) } catch (e) { console.error(n.e(`onMount error in ${t}:`, e), "application") } }), 0)), c } _handleAsyncLifecycleRender(e, t, s) { const r = this._createPlaceholder(`Loading ${t.name}...`, "juris-async-lifecycle"); return e.then((e => { try { const o = this.juris.domRenderer.render(e); o && (this.instances.set(o, t), s?.size > 0 && this.componentStates.set(o, s), r.parentNode && r.parentNode.replaceChild(o, r), t.hooks.onMount && setTimeout((() => { try { const e = t.hooks.onMount(); e?.then && i(e).catch((e => console.error(n.e(`Async onMount error in ${t.name}:`, e), "application"))) } catch (e) { console.error(n.e(`onMount error in ${t.name}:`, e), "application") } }), 0)) } catch (e) { this._replaceWithError(r, e) } })).catch((e => this._replaceWithError(r, e))), r } updateInstance(e, t) { const s = this.instances.get(e); if (!s) return; const r = s.props; deepEquals(r, t) || (this._hasAsyncProps(t) ? this._resolveAsyncProps(t).then((t => { s.props = t, this._performUpdate(s, e, r, t) })).catch((e => console.error(n.e(`Error updating async props for ${s.name}:`, e), "framework"))) : (s.props = t, this._performUpdate(s, e, r, t))) } _performUpdate(e, t, s, r) { if (e.hooks.onUpdate) try { const t = e.hooks.onUpdate(s, r); t?.then && i(t).catch((t => console.error(n.e(`Async onUpdate error in ${e.name}:`, t), "application"))) } catch (t) { console.error(n.e(`onUpdate error in ${e.name}:`, t), "application") } try { const s = e.render(), r = i(s); r !== s ? r.then((e => { this.juris.domRenderer.updateElementContent(t, e) })).catch((t => console.error(n.e(`Async re-render error in ${e.name}:`, t), "application"))) : this.juris.domRenderer.updateElementContent(t, s) } catch (t) { console.error(n.e(`Re-render error in ${e.name}:`, t), "application") } } cleanup(e) { const t = this.instances.get(e); if (t && console.debug(n.d("Cleaning up component", { name: t.name }, "framework")), t?.hooks?.onUnmount) try { const e = t.hooks.onUnmount(); e?.then && i(e).catch((e => console.error(n.e(`Async onUnmount error in ${t.name}:`, e), "application"))) } catch (e) { console.error(n.e(`onUnmount error in ${t.name}:`, e), "application") } const s = this.componentStates.get(e); s && (s.forEach((e => { const t = e.split("."); let n = this.juris.stateManager.state; for (let e = 0; e < t.length - 1; e++) { if (!n[t[e]]) return; n = n[t[e]] } delete n[t[t.length - 1]] })), this.componentStates.delete(e)), this.asyncPlaceholders.has(e) && this.asyncPlaceholders.delete(e), this.instances.delete(e) } _createPlaceholder(e, t) { const n = document.createElement("div"); return n.className = t, n.textContent = e, n.style.cssText = "padding: 8px; background: #f0f0f0; border: 1px dashed #ccc; opacity: 0.7;", n } _createErrorElement(e) { const t = document.createElement("div"); return t.style.cssText = "color: red; border: 1px solid red; padding: 8px; background: #ffe6e6;", t.textContent = `Component Error: ${e.message}`, t } _replaceWithError(e, t) { const n = this._createErrorElement(t); e.parentNode && e.parentNode.replaceChild(n, e), this.asyncPlaceholders.delete(e) } clearAsyncPropsCache() { this.asyncPropsCache.clear() } getAsyncStats() { return { activePlaceholders: this.asyncPlaceholders.size, registeredComponents: this.components.size, cachedAsyncProps: this.asyncPropsCache.size } } } class DOMRenderer { constructor(e) { console.info(n.i("DOMRenderer initialized", { renderMode: "fine-grained" }, "framework")), this.juris = e, this.subscriptions = new WeakMap, this.eventMap = { ondoubleclick: "dblclick", onmousedown: "mousedown", onmouseup: "mouseup", onmouseover: "mouseover", onmouseout: "mouseout", onmousemove: "mousemove", onkeydown: "keydown", onkeyup: "keyup", onkeypress: "keypress", onfocus: "focus", onblur: "blur", onchange: "change", oninput: "input", onsubmit: "submit", onload: "load", onresize: "resize", onscroll: "scroll" }, this.elementCache = new Map, this.recyclePool = new Map, this.renderMode = "fine-grained", this.failureCount = 0, this.maxFailures = 3, this.asyncCache = new Map, this.asyncPlaceholders = new WeakMap } setRenderMode(e) { ["fine-grained", "batch"].includes(e) ? (this.renderMode = e, console.info(n.i("Render mode changed", { mode: e }, "framework"))) : console.warn(n.w("Invalid render mode", { mode: e }, "framework")) } getRenderMode() { return this.renderMode } isFineGrained() { return "fine-grained" === this.renderMode } isBatchMode() { return "batch" === this.renderMode } render(e) { if (console.debug(n.d("Render started", { vnodeType: typeof e, isArray: Array.isArray(e) }, "framework")), !e || "object" != typeof e) return null; if (Array.isArray(e)) { const t = document.createDocumentFragment(); return e.forEach((e => { const n = this.render(e); n && t.appendChild(n) })), t } const t = Object.keys(e)[0], s = e[t] || {}; if (this.juris.componentManager.components.has(t)) { const e = this.juris.stateManager.currentTracking; this.juris.stateManager.currentTracking = null; const n = this.juris.componentManager.create(t, s); return this.juris.stateManager.currentTracking = e, n } if ("string" != typeof t || 0 === t.length) return null; if ("fine-grained" === this.renderMode) return this._createElementFineGrained(t, s); try { const e = s.key || this._generateKey(t, s), n = this.elementCache.get(e); return n && this._canReuseElement(n, t, s) ? (this._updateElementProperties(n, s), n) : this._createElementOptimized(t, s, e) } catch (e) { return this.failureCount++, this.failureCount >= this.maxFailures && (this.renderMode = "fine-grained"), this._createElementFineGrained(t, s) } } _createElementFineGrained(e, t) { console.debug(n.d("Creating element (fine-grained)", { tagName: e, propsCount: Object.keys(t).length }, "framework")); const s = document.createElement(e), r = [], i = []; return this._hasAsyncProps(t) ? this._setupAsyncElement(s, t, r, i) : this._setupSyncElement(s, t, r, i), (r.length > 0 || i.length > 0) && this.subscriptions.set(s, { subscriptions: r, eventListeners: i }), s } _hasAsyncProps(e) { return Object.entries(e).some((([e, t]) => !e.startsWith("on") && this._isPromiseLike(t))) } _isPromiseLike(e) { return e?.then } _setupAsyncElement(e, t, s, r) { const i = Object.entries(t).filter((([e, t]) => !e.startsWith("on") && this._isPromiseLike(t))).length; console.debug(n.d("Setting up async element", { tagName: e.tagName, asyncPropsCount: i }, "framework")); const o = {}, a = {}; Object.entries(t).forEach((([t, n]) => { t.startsWith("on") ? this._handleEvent(e, t, n, r) : this._isPromiseLike(n) ? (a[t] = n, this._setPlaceholder(e, t)) : o[t] = n })), this._setupSyncElement(e, o, s, r), Object.keys(a).length > 0 && this._resolveAsyncProps(e, a, s) } _setupSyncElement(e, t, n, s) { Object.entries(t).forEach((([t, r]) => { "children" === t ? this._handleChildren(e, r, n) : "text" === t ? this._handleText(e, r, n) : "style" === t ? this._handleStyle(e, r, n) : t.startsWith("on") ? this._handleEvent(e, t, r, s) : "function" == typeof r ? this._handleReactiveAttribute(e, t, r, n) : "key" !== t && this._setStaticAttribute(e, t, r) })) } _setPlaceholder(e, t) { ({ text: () => { e.textContent = "...", e.classList.add("juris-async-loading") }, children: () => { const t = document.createElement("span"); t.textContent = "Loading...", t.className = "juris-async-loading", e.appendChild(t) }, className: () => e.classList.add("juris-async-loading"), style: () => { e.style.opacity = "0.7", e.classList.add("juris-async-loading") } }[t] || (() => e.setAttribute(t, "loading")))() } _resolveAsyncProps(e, t, n) { const s = this._generateAsyncCacheKey(t), r = this.asyncCache.get(s); if (r && Date.now() - r.timestamp < 5e3) return void this._applyResolvedProps(e, r.props, n); const o = Object.entries(t).map((([e, t]) => i(t).then((t => ({ key: e, value: t, success: !0 }))).catch((t => ({ key: e, error: t.message, success: !1 }))))); Promise.all(o).then((t => { const r = {}; t.forEach((({ key: e, value: t, error: n, success: s }) => { r[e] = s ? t : { __asyncError: n } })), this.asyncCache.set(s, { props: r, timestamp: Date.now() }), this._applyResolvedProps(e, r, n) })) } _applyResolvedProps(e, t, s) { e.classList.remove("juris-async-loading"), Object.entries(t).forEach((([t, r]) => { if (r?.__asyncError) return console.error(n.e(`Async prop '${t}' failed:`, r.__asyncError), "application"), void this._setErrorState(e, t, r.__asyncError); "children" === t ? this._handleAsyncChildren(e, r, s) : "text" === t ? e.textContent = r : "style" === t ? Object.assign(e.style, "object" == typeof r ? r : {}) : "innerHTML" === t ? e.innerHTML = r : this._setStaticAttribute(e, t, r) })) } _setErrorState(e, t, n) { e.classList.add("juris-async-error"), "text" === t ? e.textContent = `Error: ${n}` : "children" === t && (e.innerHTML = `<span class="juris-async-error">Error: ${n}</span>`) } _handleAsyncChildren(e, t, n) { if (e.innerHTML = "", Array.isArray(t)) t.forEach((t => { const n = this.render(t); n && e.appendChild(n) })); else if (t) { const n = this.render(t); n && e.appendChild(n) } } _generateAsyncCacheKey(e) { return JSON.stringify(e, ((e, t) => this._isPromiseLike(t) ? "[Promise]" : t)) } _handleChildren(e, t, n) { "fine-grained" === this.renderMode ? this._handleChildrenFineGrained(e, t, n) : this._handleChildrenOptimized(e, t, n) } _handleChildrenFineGrained(e, t, n) { "function" == typeof t ? this._handleReactiveChildren(e, t, n) : this._isPromiseLike(t) ? this._handleAsyncChildrenDirect(e, t) : this._updateChildren(e, t) } _handleChildrenOptimized(e, t, s) { if ("function" == typeof t) { let r = null, o = [], a = !0; const updateChildren = () => { try { const s = t(); if (this._isPromiseLike(s)) i(s).then((t => { if ("ignore" !== t && !this._childrenEqual(r, t)) if (a) try { o = this._reconcileChildren(e, o, t), r = t } catch (n) { console.warn("Reconciliation failed, falling back to safe rendering:", n.message), a = !1, this._updateChildren(e, t), r = t } else this._updateChildren(e, t), r = t })).catch((e => { console.error(n.e("Error in async children function:", e), "framework"), a = !1 })); else if ("ignore" !== s && !this._childrenEqual(r, s)) if (a) try { o = this._reconcileChildren(e, o, s), r = s } catch (t) { console.warn("Reconciliation failed, falling back to safe rendering:", t.message), a = !1, this._updateChildren(e, s), r = s } else this._updateChildren(e, s), r = s } catch (t) { console.error(n.e("Error in children function:", t), "framework"), a = !1; try { this._updateChildren(e, []) } catch (e) { console.error(n.e("Even safe fallback failed:", e), "framework") } } }; this._createReactiveUpdate(e, updateChildren, s); try { const s = t(); this._isPromiseLike(s) ? i(s).then((t => { o = this._reconcileChildren(e, [], t), r = t })).catch((t => { console.warn(n.w("Initial async children failed, using safe method:", t.message), "framework"), a = !1, this._updateChildren(e, []) })) : (o = this._reconcileChildren(e, [], s), r = s) } catch (s) { console.warn(n.w("Initial reconciliation failed, using safe method:", s.message), "framework"), a = !1; const i = t(); this._updateChildren(e, i), r = i } } else if (this._isPromiseLike(t)) this._handleAsyncChildrenDirect(e, t); else try { this._reconcileChildren(e, [], t) } catch (s) { console.warn(n.w("Static reconciliation failed, using safe method:", s.message), "framework"), this._updateChildren(e, t) } } _childrenEqual(e, t) { return deepEquals && deepEquals(e, t) } _reconcileChildren(e, t, s) { console.debug(n.d("Reconciling children", { parentTag: e.tagName, oldCount: t.length, newCount: Array.isArray(s) ? s.length : s ? 1 : 0 }, "framework")), Array.isArray(s) || (s = s ? [s] : []); const r = [], i = document.createDocumentFragment(), o = new Map; t.forEach(((e, t) => { const n = e._jurisKey || `auto-${t}`; o.set(n, e) })); const a = new Set; s.forEach(((t, n) => { if (!t || "object" != typeof t) return; const s = Object.keys(t)[0], c = t[s] || {}, h = c.key || this._generateKey(s, c, n), l = o.get(h); if (l && !a.has(l) && this._canReuseElement(l, s, c) && !this._wouldCreateCircularReference(e, l)) l.parentNode && l.parentNode.removeChild(l), this._updateElementProperties(l, c), r.push(l), i.appendChild(l), a.add(l), o.delete(h); else { const n = this.render(t); n && !this._wouldCreateCircularReference(e, n) && (n._jurisKey = h, r.push(n), i.appendChild(n)) } })), o.forEach((e => { a.has(e) || this._recycleElement(e) })); try { e.textContent = "", i.hasChildNodes() && e.appendChild(i) } catch (t) { console.error(n.e("Error in reconcileChildren:", t), "framework"), e.textContent = "", r.forEach((t => { try { t && !this._wouldCreateCircularReference(e, t) && e.appendChild(t) } catch (t) { console.error(n.e("Reconciliation failed", { parentTag: e.tagName, error: t.message }, "framework")) } })) } return r } _wouldCreateCircularReference(e, t) { if (!e || !t) return !1; if (e === t) return !0; try { let n = e.parentNode; for (; n;) { if (n === t) return !0; n = n.parentNode } if (t.contains && t.contains(e)) return !0; if (t.children) for (let n of t.children) if (this._wouldCreateCircularReference(e, n)) return !0 } catch (e) { return console.warn(n.w("Error checking circular reference, assuming unsafe:", e), "framework"), !0 } return !1 } _recycleElement(e) { if (!e || !e.tagName) return; const t = e.tagName.toLowerCase(); e.parentNode && e.parentNode.removeChild(e), this.recyclePool.has(t) || this.recyclePool.set(t, []); const n = this.recyclePool.get(t); n.length < 100 && (this.cleanup(e), this._resetElement(e), n.push(e)) } _handleAsyncChildrenDirect(e, t) { const s = document.createElement("div"); s.className = "juris-async-loading", s.textContent = "Loading content...", e.appendChild(s), this.asyncPlaceholders.set(e, { type: "children", placeholder: s }), i(t).then((t => { s.parentNode && e.removeChild(s), this._updateChildren(e, t), this.asyncPlaceholders.delete(e) })).catch((e => { console.error(n.e("Async children failed:", e), "application"), s.textContent = `Error loading content: ${e.message}`, s.className = "juris-async-error" })) } _handleReactiveChildren(e, t, s) { let r = null, o = !1; this._createReactiveUpdate(e, (() => { try { const s = t(); this._isPromiseLike(s) ? i(s).then((t => { "ignore" === t || o && deepEquals(t, r) || (this._updateChildren(e, t), r = t, o = !0) })).catch((e => console.error(n.e("Error in async reactive children:", e), "application"))) : "ignore" === s || o && deepEquals(s, r) || (this._updateChildren(e, s), r = s, o = !0) } catch (e) { console.error(n.e("Error in reactive children function:", e), "application") } }), s) } _updateChildren(e, t) { if ("ignore" === t) return; Array.from(e.children).forEach((e => this.cleanup(e))), e.textContent = ""; const n = document.createDocumentFragment(); if (Array.isArray(t)) t.forEach((e => { const t = this.render(e); t && n.appendChild(t) })); else if (t) { const e = this.render(t); e && n.appendChild(e) } n.hasChildNodes() && e.appendChild(n) } _handleText(e, t, n) { "function" == typeof t ? this._handleReactiveText(e, t, n) : this._isPromiseLike(t) ? this._handleAsyncTextDirect(e, t) : e.textContent = t } _handleAsyncTextDirect(e, t) { e.textContent = "Loading...", e.classList.add("juris-async-loading"), i(t).then((t => { e.textContent = t, e.classList.remove("juris-async-loading") })).catch((t => { console.error(n.e("Async text failed:", t), "application"), e.textContent = `Error: ${t.message}`, e.classList.add("juris-async-error") })) } _handleReactiveText(e, t, s) { let r = null, o = !1; this._createReactiveUpdate(e, (() => { try { const s = t(); this._isPromiseLike(s) ? i(s).then((t => { o && t === r || (e.textContent = t, r = t, o = !0) })).catch((e => console.error(n.e("Error in async reactive text:", e), "application"))) : o && s === r || (e.textContent = s, r = s, o = !0) } catch (e) { console.error(n.e("Error in reactive text function:", e), "application") } }), s) } _handleStyle(e, t, n) { "function" == typeof t ? this._handleReactiveStyle(e, t, n) : this._isPromiseLike(t) ? this._handleAsyncStyleDirect(e, t) : "object" == typeof t && Object.assign(e.style, t) } _handleAsyncStyleDirect(e, t) { e.style.opacity = "0.7", e.classList.add("juris-async-loading"), i(t).then((t => { e.style.opacity = "", e.classList.remove("juris-async-loading"), "object" == typeof t && Object.assign(e.style, t) })).catch((e => console.error(n.e("Async style failed:", e), "application"))) } _handleReactiveStyle(e, t, s) { let r = null, o = !1; this._createReactiveUpdate(e, (() => { try { const s = t(); this._isPromiseLike(s) ? i(s).then((t => { o && deepEquals(t, r) || "object" == typeof t && (Object.assign(e.style, t), r = { ...t }, o = !0) })).catch((e => console.error(n.e("Error in async reactive style:", e), "application"))) : o && deepEquals(s, r) || "object" == typeof s && (Object.assign(e.style, s), r = { ...s }, o = !0) } catch (e) { console.error(n.e("Error in reactive style function:", e), "application") } }), s) } _createElementOptimized(e, t, n) { let s = this._getRecycledElement(e); s || (s = document.createElement(e)), n && (this.elementCache.set(n, s), s._jurisKey = n); const r = [], i = []; return this._processProperties(s, t, r, i), (r.length > 0 || i.length > 0) && this.subscriptions.set(s, { subscriptions: r, eventListeners: i }), s } _processProperties(e, t, n, s) { Object.keys(t).forEach((r => { const i = t[r]; "children" === r ? this._handleChildren(e, i, n) : "text" === r ? this._handleText(e, i, n) : "innerHTML" === r ? "function" == typeof i ? this._handleReactiveAttribute(e, r, i, n) : e.innerHTML = i : "style" === r ? this._handleStyle(e, i, n) : r.startsWith("on") ? this._handleEvent(e, r, i, s) : "function" == typeof i ? this._handleReactiveAttribute(e, r, i, n) : "key" !== r && this._setStaticAttribute(e, r, i) })) } _handleEvent(e, t, s, r) { if (console.debug(n.d("Event handler attached", { tagName: e.tagName, eventName: t }, "framework")), "onclick" === t) { e.style.touchAction = "manipulation", e.style.webkitTapHighlightColor = "transparent", e.style.webkitTouchCallout = "none", e.addEventListener("click", s), r.push({ eventName: "click", handler: s }); let t = 0, n = !1, i = 0, o = 0; const touchStart = e => { t = Date.now(), n = !1, e.touches?.[0] && (i = e.touches[0].clientX, o = e.touches[0].clientY) }, touchMove = e => { if (e.touches?.[0]) { const t = Math.abs(e.touches[0].clientX - i), s = Math.abs(e.touches[0].clientY - o); (t > 10 || s > 10) && (n = !0) } }, touchEnd = e => { const r = Date.now() - t; !n && r < 300 && (e.preventDefault(), e.stopPropagation(), s(e)) }; e.addEventListener("touchstart", touchStart, { passive: !0 }), e.addEventListener("touchmove", touchMove, { passive: !0 }), e.addEventListener("touchend", touchEnd, { passive: !1 }), r.push({ eventName: "touchstart", handler: touchStart }, { eventName: "touchmove", handler: touchMove }, { eventName: "touchend", handler: touchEnd }) } else { const n = this.eventMap[t.toLowerCase()] || t.slice(2).toLowerCase(); e.addEventListener(n, s), r.push({ eventName: n, handler: s }) } } _handleReactiveAttribute(e, t, s, r) { let o = null, a = !1; this._createReactiveUpdate(e, (() => { try { const r = s(); this._isPromiseLike(r) ? i(r).then((n => { a && deepEquals(n, o) || (this._setStaticAttribute(e, t, n), o = n, a = !0) })).catch((e => console.error(n.e(`Error in async reactive attribute '${t}':`, e), "application"))) : a && deepEquals(r, o) || (this._setStaticAttribute(e, t, r), o = r, a = !0) } catch (e) { console.error(n.e(`Error in reactive attribute '${t}':`, e), "application") } }), r) } _setStaticAttribute(e, t, n) { if (!["children", "key"].includes(t)) { if ("function" == typeof n) return "value" === t && ["INPUT", "TEXTAREA", "SELECT"].includes(e.tagName) ? void (e.value = n()) : void console.warn(`Function value for attribute '${t}' should be handled reactively`); if ("className" === t) e.className = n; else if ("htmlFor" === t) e.setAttribute("for", n); else if ("tabIndex" === t) e.tabIndex = n; else if (t.startsWith("data-") || t.startsWith("aria-")) e.setAttribute(t, n); else if (t in e && "function" != typeof e[t]) try { const s = Object.getOwnPropertyDescriptor(e, t) || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(e), t); s && !1 === s.writable ? e.setAttribute(t, n) : e[t] = n } catch (s) { e.setAttribute(t, n) } else e.setAttribute(t, n) } } _createReactiveUpdate(e, t, s) { const r = this.juris.stateManager.startTracking(), i = this.juris.stateManager.currentTracking; this.juris.stateManager.currentTracking = r; try { t() } catch (e) { console.error(n.e("Error capturing dependencies:", e), "application") } finally { this.juris.stateManager.currentTracking = i } r.forEach((e => { const n = this.juris.stateManager.subscribeInternal(e, t); s.push(n) })) } updateElementContent(e, t) { this._updateChildren(e, [t]) } cleanup(e) { console.debug(n.d("Cleaning up element", { tagName: e.tagName, hasSubscriptions: this.subscriptions.has(e) }, "framework")), this.juris.componentManager.cleanup(e); const t = this.subscriptions.get(e); t && (t.subscriptions?.forEach((e => { try { e() } catch (e) { console.warn("Error during subscription cleanup:", e) } })), t.eventListeners?.forEach((({ eventName: t, handler: n }) => { try { e.removeEventListener(t, n) } catch (e) { console.warn("Error during event listener cleanup:", e) } })), this.subscriptions.delete(e)), e._jurisKey && this.elementCache.delete(e._jurisKey), this.asyncPlaceholders.has(e) && this.asyncPlaceholders.delete(e); try { Array.from(e.children || []).forEach((e => { try { this.cleanup(e) } catch (e) { console.warn("Error cleaning up child element:", e) } })) } catch (e) { console.warn("Error during children cleanup:", e) } } _generateKey(e, t) { if (t.key) return t.key; const n = [e];["id", "className", "text"].forEach((e => { t[e] && "function" != typeof t[e] && n.push(`${e}:${t[e]}`) })); const s = this._hashProps(t); return n.push(`hash:${s}`), n.join("|") } _hashProps(e) { const t = JSON.stringify(e, ((e, t) => "function" == typeof t ? "[function]" : t)); let n = 0; for (let e = 0; e < t.length; e++) { n = (n << 5) - n + t.charCodeAt(e), n &= n } return Math.abs(n).toString(36) } _getRecycledElement(e) { const t = this.recyclePool.get(e); if (t?.length > 0) { const e = t.pop(); return this._resetElement(e), e } return null } _resetElement(e) { e.textContent = "", e.className = "", e.removeAttribute("style"); const t = ["id", "data-juris-key"]; Array.from(e.attributes).forEach((n => { t.includes(n.name) || e.removeAttribute(n.name) })) } _canReuseElement(e, t, n) { return e.tagName.toLowerCase() === t.toLowerCase() } _updateElementProperties(e, t) { Object.keys(t).forEach((n => { if (!["key", "children", "text", "style"].includes(n)) { const s = t[n]; "function" != typeof s && this._setStaticAttribute(e, n, s) } })) } clearAsyncCache() { this.asyncCache.clear() } getAsyncStats() { return { cachedAsyncProps: this.asyncCache.size, activePlaceholders: this.asyncPlaceholders.size } } } class DOMEnhancer { constructor(e) { console.info(n.i("DOMEnhancer initialized", {}, "framework")), this.juris = e, this.observers = new Map, this.enhancedElements = new WeakSet, this.enhancementRules = new Map, this.containerEnhancements = new WeakMap, this.options = { debounceMs: 5, batchUpdates: !0, observeSubtree: !0, observeChildList: !0 }, this.pendingEnhancements = new Set, this.enhancementTimer = null } enhance(e, t, s = {}) { console.info(n.i("Enhancement registered", { selector: e, hasSelectors: this._hasSelectorsCategory(t), optionKeys: Object.keys(s) }, "framework")); const r = { ...this.options, ...s }; return this._hasSelectorsCategory(t) ? this._enhanceWithSelectors(e, t, r) : (this.enhancementRules.set(e, { definition: t, config: r, type: "simple" }), this._enhanceExistingElements(e, t, r), !1 !== r.observeNewElements && this._setupMutationObserver(e, t, r), () => this._unenhance(e)) } _hasSelectorsCategory(e) { if (e?.selectors) return !0; if ("function" == typeof e) try { const t = e(this.juris.createContext()); return t?.selectors } catch (e) { return !1 } return !1 } _enhanceWithSelectors(e, t, n) { return this.enhancementRules.set(e, { definition: t, config: n, type: "selectors" }), this._enhanceExistingContainers(e, t, n), !1 !== n.observeNewElements && this._setupSelectorsObserver(e, t, n), () => this._unenhanceSelectors(e) } _enhanceExistingContainers(e, t, n) { document.querySelectorAll(e).forEach((e => this._enhanceContainer(e, t, n))) } _enhanceContainer(e, t, s) { if (!this.enhancedElements.has(e)) try { this.enhancedElements.add(e), e.setAttribute("data-juris-enhanced-container", Date.now()); let n = t; if ("function" == typeof t) { n = t(this.juris.createContext(e)) } if (!n?.selectors) return void console.warn('Selectors enhancement must have a "selectors" property'); const r = new Map; this.containerEnhancements.set(e, r), this._applyContainerProperties(e, n), Object.entries(n.selectors).forEach((([t, n]) => { this._enhanceSelector(e, t, n, r, s) })) } catch (t) { console.error(n.e("Error enhancing container:", t), "application"), this.enhancedElements.delete(e) } } _applyContainerProperties(e, t) { const n = { ...t }; delete n.selectors, Object.keys(n).length > 0 && this._applyEnhancements(e, n) } _enhanceSelector(e, t, n, s, r) { const i = e.querySelectorAll(t), o = new Set; i.forEach((s => { this.enhancedElements.has(s) || (this._enhanceSelectorElement(s, n, e, t), o.add(s)) })), s.set(t, { definition: n, enhancedElements: o }) } _enhanceSelectorElement(e, t, s, r) { try { this.enhancedElements.add(e), e.setAttribute("data-juris-enhanced-selector", Date.now()); let n = t; if ("function" == typeof t) { if (n = t(this.juris.createContext(e)), !n || "object" != typeof n) return console.warn(`Selector '${r}' function must return a definition object`), void this.enhancedElements.delete(e) } const s = this._processElementAwareFunctions(e, n); this._applyEnhancements(e, s) } catch (t) { console.error(n.e("Error enhancing selector element:", t), "application"), this.enhancedElements.delete(e) } } _processElementAwareFunctions(e, t) { const n = {}; return Object.entries(t).forEach((([t, s]) => { if ("function" == typeof s) if (t.startsWith("on")) n[t] = s; else if (s.length > 0) try { const r = s(this.juris.createContext(e)); n[t] = r && "object" == typeof r ? r : s } catch (e) { console.warn(`Error processing element-aware function '${t}':`, e), n[t] = s } else n[t] = s; else n[t] = s })), n } _setupSelectorsObserver(e, t, n) { const s = `selectors_${e}`; if (this.observers.has(s)) return; const r = new MutationObserver((s => { n.debounceMs > 0 ? this._debouncedProcessSelectorsMutations(s, e, t, n) : this._processSelectorsMutations(s, e, t, n) })); r.observe(document.body, { childList: n.observeChildList, subtree: n.observeSubtree }), this.observers.set(s, r) } _processSelectorsMutations(e, t, n, s) { e.forEach((e => { "childList" === e.type && e.addedNodes.forEach((e => { e.nodeType === Node.ELEMENT_NODE && this._handleNewNodeForSelectors(e, t, n, s) })) })) } _handleNewNodeForSelectors(e, t, n, s) { e.matches?.(t) && this._enhanceContainer(e, n, s), e.querySelectorAll && e.querySelectorAll(t).forEach((e => { this._enhanceContainer(e, n, s) })), this._enhanceNewElementsInContainers(e) } _enhanceNewElementsInContainers(e) { document.querySelectorAll("[data-juris-enhanced-container]").forEach((t => { if (!t.contains(e)) return; const n = this.containerEnhancements.get(t); n && n.forEach(((n, s) => { const { definition: r, enhancedElements: i } = n; e.matches?.(s) && (this._enhanceSelectorElement(e, r, t, s), i.add(e)), e.querySelectorAll && e.querySelectorAll(s).forEach((e => { this.enhancedElements.has(e) || (this._enhanceSelectorElement(e, r, t, s), i.add(e)) })) })) })) } _debouncedProcessSelectorsMutations(e, t, n, s) { e.forEach((e => { "childList" === e.type && e.addedNodes.forEach((e => { e.nodeType === Node.ELEMENT_NODE && this.pendingEnhancements.add({ node: e, containerSelector: t, definition: n, config: s, type: "selectors", timestamp: Date.now() }) })) })), this.enhancementTimer && clearTimeout(this.enhancementTimer), this.enhancementTimer = setTimeout((() => { this._processPendingEnhancements(), this.enhancementTimer = null }), s.debounceMs) } _unenhanceSelectors(e) { const t = `selectors_${e}`, n = this.observers.get(t); n && (n.disconnect(), this.observers.delete(t)), this.enhancementRules.delete(e), document.querySelectorAll(`${e}[data-juris-enhanced-container]`).forEach((e => { this._cleanupContainer(e) })) } _cleanupContainer(e) { const t = this.containerEnhancements.get(e); t && (t.forEach((e => { e.enhancedElements.forEach((e => this._cleanupElement(e))) })), this.containerEnhancements.delete(e)), this._cleanupElement(e), e.removeAttribute("data-juris-enhanced-container") } _enhanceExistingElements(e, t, n) { const s = document.querySelectorAll(e); n.batchUpdates && s.length > 1 ? this._batchEnhanceElements(Array.from(s), t, n) : s.forEach((e => this._enhanceElement(e, t, n))) } _batchEnhanceElements(e, t, n) { e.filter((e => !this.enhancedElements.has(e))).forEach((e => this._enhanceElement(e, t, n))) } _enhanceElement(e, t, s) { if (this.enhancedElements.has(e)) console.debug(n.d("Element already enhanced", { tagName: e.tagName }, "framework")); else try { console.debug(n.d("Enhancing element", { tagName: e.tagName, definitionKeys: Object.keys(t) }, "framework")), this.enhancedElements.add(e), e.setAttribute("data-juris-enhanced", Date.now()); let r = t; if ("function" == typeof t) { if (r = t(this.juris.createContext(e)), !r || "object" != typeof r) return console.warn("Enhancement function must return a definition object"), void this.enhancedElements.delete(e) } this._applyEnhancements(e, r), s.onEnhanced?.(e, this.juris.createContext(e)) } catch (t) { console.error(n.e("Element enhancement failed", { tagName: e.tagName, error: t.message }, "framework")), this.enhancedElements.delete(e) } } _applyEnhancements(e, t) { const s = [], r = [], i = this.juris.domRenderer; Object.keys(t).forEach((o => { const a = t[o]; try { "children" === o ? this._handleChildren(e, a, s, i) : "text" === o ? i._handleText(e, a, s) : "innerHTML" === o ? this._handleInnerHTML(e, a, s, i) : "style" === o ? i._handleStyle(e, a, s) : o.startsWith("on") ? i._handleEvent(e, o, a, r) : "function" == typeof a ? i._handleReactiveAttribute(e, o, a, s) : i._setStaticAttribute(e, o, a) } catch (e) { console.error(n.e(`Error processing enhancement property '${o}':`, e), "framework") } })), (s.length > 0 || r.length > 0) && this.juris.domRenderer.subscriptions.set(e, { subscriptions: s, eventListeners: r }) } _handleChildren(e, t, n, s) { s.isFineGrained() ? s._handleChildrenFineGrained(e, t, n) : s._handleChildrenOptimized(e, t, n) } _handleInnerHTML(e, t, n, s) { "function" == typeof t ? s._handleReactiveAttribute(e, "innerHTML", t, n) : e.innerHTML = t } _setupMutationObserver(e, t, n) { if (this.observers.has(e)) return; const s = new MutationObserver((s => { n.debounceMs > 0 ? this._debouncedProcessMutations(s, e, t, n) : this._processMutations(s, e, t, n) })); s.observe(document.body, { childList: n.observeChildList, subtree: n.observeSubtree }), this.observers.set(e, s) } _processMutations(e, t, s, r) { console.debug(n.d("Processing DOM mutations", { selector: t, mutationCount: e.length, addedNodesCount: e.reduce(((e, t) => e + t.addedNodes.length), 0) }, "framework")), e.forEach((e => { "childList" === e.type && e.addedNodes.forEach((e => { e.nodeType === Node.ELEMENT_NODE && this._enhanceNewNode(e, t, s, r) })) })) } _enhanceNewNode(e, t, n, s) { e.matches?.(t) && this._enhanceElement(e, n, s), e.querySelectorAll && e.querySelectorAll(t).forEach((e => { this._enhanceElement(e, n, s) })) } _debouncedProcessMutations(e, t, n, s) { e.forEach((e => { "childList" === e.type && e.addedNodes.forEach((e => { e.nodeType === Node.ELEMENT_NODE && this.pendingEnhancements.add({ node: e, selector: t, definition: n, config: s, timestamp: Date.now() }) })) })), this.enhancementTimer && clearTimeout(this.enhancementTimer), this.enhancementTimer = setTimeout((() => { this._processPendingEnhancements(), this.enhancementTimer = null }), s.debounceMs) } _processPendingEnhancements() { const e = Array.from(this.pendingEnhancements); this.pendingEnhancements.clear(), e.forEach((({ node: e, selector: t, definition: s, config: r, containerSelector: i, type: o }) => { try { "selectors" === o ? this._handleNewNodeForSelectors(e, i, s, r) : this._enhanceNewNode(e, t, s, r) } catch (e) { console.error(n.e("Error processing pending enhancement:", e), "framework") } })) } _unenhance(e) { const t = this.observers.get(e); t && (t.disconnect(), this.observers.delete(e)), this.enhancementRules.delete(e), document.querySelectorAll(`${e}[data-juris-enhanced]`).forEach((e => { this._cleanupElement(e) })) } _cleanupElement(e) { this.juris.domRenderer.cleanup(e), this.enhancedElements.delete(e), e.removeAttribute("data-juris-enhanced"), e.removeAttribute("data-juris-enhanced-selector") } configure(e) { Object.assign(this.options, e) } getStats() { const e = document.querySelectorAll("[data-juris-enhanced]").length, t = document.querySelectorAll("[data-juris-enhanced-container]").length, n = document.querySelectorAll("[data-juris-enhanced-selector]").length; return { enhancementRules: this.enhancementRules.size, activeObservers: this.observers.size, pendingEnhancements: this.pendingEnhancements.size, enhancedElements: e, enhancedContainers: t, enhancedSelectors: n, totalEnhanced: e + n } } destroy() { this.observers.forEach((e => e.disconnect())), this.observers.clear(), this.enhancementRules.clear(), this.enhancementTimer && (clearTimeout(this.enhancementTimer), this.enhancementTimer = null), document.querySelectorAll("[data-juris-enhanced], [data-juris-enhanced-selector]").forEach((e => { this._cleanupElement(e) })), document.querySelectorAll("[data-juris-enhanced-container]").forEach((e => { this._cleanupContainer(e) })), this.pendingEnhancements.clear() } } class Juris { constructor(e = {}) { e.logLevel && this.setupLogging(e.logLevel), console.info(n.i("Juris framework initializing", { hasServices: !!e.services, hasLayout: !!e.layout, hasStates: !!e.states, hasComponents: !!e.components, renderMode: e.renderMode || "auto" }, "framework")), this.services = e.services || {}, this.layout = e.layout, this.stateManager = new StateManager(e.states || {}, e.middleware || []), this.headlessManager = new HeadlessManager(this), this.componentManager = new ComponentManager(this), this.domRenderer = new DOMRenderer(this), this.domEnhancer = new DOMEnhancer(this), e.headlessComponents && Object.entries(e.headlessComponents).forEach((([e, t]) => { "function" == typeof t ? this.headlessManager.register(e, t) : this.headlessManager.register(e, t.fn, t.options) })), this.headlessManager.initializeQueued(), "fine-grained" === e.renderMode ? this.domRenderer.setRenderMode("fine-grained") : "batch" === e.renderMode && this.domRenderer.setRenderMode("batch"), e.components && Object.entries(e.components).forEach((([e, t]) => { this.componentManager.register(e, t) })), console.info(n.i("Juris framework initialized", { componentsCount: this.componentManager.components.size, headlessCount: this.headlessManager.components.size }, "framework")) } setupLogging(e) { const t = { debug: 0, info: 1, warn: 2, error: 3 }[e] || 1; t > 0 && (console.debug = () => { }), t > 1 && (console.log("Juris logging initialized at level:", e), console.log('To change log level, use juris.setupLogging("newLevel") or set logLevel in config'), console.log = () => { }, console.info = () => { }) } createHeadlessContext(e = null) { const t = { getState: (e, t, n) => this.stateManager.getState(e, t, n), setState: (e, t, n) => this.stateManager.setState(e, t, n), subscribe: (e, t) => this.stateManager.subscribe(e, t), services: this.services, ...this.services || {}, headless: this.headlessManager.context, ...this.headlessAPIs || {}, components: { register: (e, t) => this.componentManager.register(e, t), registerHeadless: (e, t, n) => this.headlessManager.register(e, t, n), get: e => this.componentManager.components.get(e), getHeadless: e => this.headlessManager.getInstance(e), initHeadless: (e, t) => this.headlessManager.initialize(e, t), reinitHeadless: (e, t) => this.headlessManager.reinitialize(e, t) }, utils: { render: e => this.render(e), cleanup: () => this.cleanup(), forceRender: () => this.render(), getHeadlessStatus: () => this.headlessManager.getStatus() }, juris: this, logger: { log: n, lwarn: n.w, error: n.e, info: n.i, debug: n.d, subscribe: s, unsubscribe: r } }; return e && (t.element = e), t } createContext(e = null) { const t = { getState: (e, t, n) => this.stateManager.getState(e, t, n), setState: (e, t, n) => this.stateManager.setState(e, t, n), subscribe: (e, t) => this.stateManager.subscribe(e, t), services: this.services, ...this.services || {}, ...this.headlessAPIs || {}, headless: this.headlessManager.context, components: { register: (e, t) => this.componentManager.register(e, t), registerHeadless: (e, t, n) => this.headlessManager.register(e, t, n), get: e => this.componentManager.components.get(e), getHeadless: e => this.headlessManager.getInstance(e), initHeadless: (e, t) => this.headlessManager.initialize(e, t), reinitHeadless: (e, t) => this.headlessManager.reinitialize(e, t), getHeadlessAPI: e => this.headlessManager.getAPI(e), getAllHeadlessAPIs: () => this.headlessManager.getAllAPIs() }, utils: { render: e => this.render(e), cleanup: () => this.cleanup(), forceRender: () => this.render(), setRenderMode: e => this.setRenderMode(e), getRenderMode: () => this.getRenderMode(), isFineGrained: () => this.isFineGrained(), isBatchMode: () => this.isBatchMode(), getHeadlessStatus: () => this.headlessManager.getStatus() }, juris: this, logger: { log: n, lwarn: n.w, error: n.e, info: n.i, debug: n.d, subscribe: s, unsubscribe: r } }; return e && (t.element = e), t } getState(e, t, n) { return this.stateManager.getState(e, t, n) } setState(e, t, s) { return console.debug(n.d("Public setState called", { path: e }, "application")), this.stateManager.setState(e, t, s) } subscribe(e, t, n = !0) { return this.stateManager.subscribe(e, t, n) } subscribeExact(e, t) { return this.stateManager.subscribeExact(e, t) } registerComponent(e, t) { return console.info(n.i("Public component registration", { name: e }, "application")), this.componentManager.register(e, t) } registerHeadlessComponent(e, t, n) { return this.headlessManager.register(e, t, n) } getComponent(e) { return this.componentManager.components.get(e) } getHeadlessComponent(e) { return this.headlessManager.getInstance(e) } initializeHeadlessComponent(e, t) { return this.headlessManager.initialize(e, t) } setRenderMode(e) { this.domRenderer.setRenderMode(e) } getRenderMode() { return this.domRenderer.getRenderMode() } isFineGrained() { return this.domRenderer.isFineGrained() } isBatchMode() { return this.domRenderer.isBatchMode() } _updateComponentContexts() { this.headlessAPIs } registerAndInitHeadless(e, t, n = {}) { return this.headlessManager.register(e, t, n), this.headlessManager.initialize(e, n) } getHeadlessStatus() { return this.headlessManager.getStatus() } objectToHtml(e) { return this.domRenderer.render(e) } render(e = "#app") { const t = performance.now(); console.info(n.i("Render started", { container: e }, "application")); const s = "string" == typeof e ? document.querySelector(e) : e; if (!s) return void console.error(n.e("Render container not found", { container: e }, "application")); const r = this.getState("isHydration", !1); console.debug(n.d("Render mode determined", { isHydration: r }, "framework")); try { r ? this._renderWithHydration(s) : this._renderImmediate(s); const e = performance.now() - t; console.info(n.i("Render completed", { duration: `${e.toFixed(2)}ms`, isHydration: r }, "application")) } catch (t) { console.error(n.e("Render failed", { error: t.message, container: e }, "application")), this._renderError(s, t) } } _renderImmediate = function (e) { e.innerHTML = ""; const t = this.domRenderer.render(this.layout); t && e.appendChild(t) }; _renderWithHydration = async function (e) { const t = document.createElement("div"); t.style.cssText = "position: absolute; left: -9999px; visibility: hidden;", document.body.appendChild(t); try { o(); const n = this.domRenderer.render(this.layout); for (n && t.appendChild(n), await c(), e.innerHTML = ""; t.firstChild;)e.appendChild(t.firstChild); this.headlessManager.initializeQueued() } finally { a(), document.body.removeChild(t) } }; _renderError(e, t) { const n = document.createElement("div"); n.style.cssText = "color: red; border: 2px solid red; padding: 16px; margin: 8px; background: #ffe6e6;", n.innerHTML = `\n                <h3>Render Error</h3>\n                <p><strong>Message:</strong> ${t.message}</p>\n                <pre style="background: #f5f5f5; padding: 8px; overflow: auto;">${t.stack || ""}</pre>\n            `, e.appendChild(n) } enhance(e, t, n) { return this.domEnhancer.enhance(e, t, n) } configureEnhancement(e) { return this.domEnhancer.configure(e) } getEnhancementStats() { return this.domEnhancer.getStats() } cleanup() { console.info(n.i("Framework cleanup initiated", {}, "application")), this.headlessManager.cleanup() } destroy() { console.info(n.i("Framework destruction initiated", {}, "application")), this.cleanup(), this.domEnhancer.destroy(), this.stateManager.subscribers.clear(), this.stateManager.externalSubscribers.clear(), this.componentManager.components.clear(), this.headlessManager.components.clear(), console.info(n.i("Framework destroyed", {}, "application")) } } "undefined" != typeof window && (window.Juris = Juris, window.deepEquals = deepEquals, window.jurisVersion = e, window.jurisLinesOfCode = 2558, window.jurisMinifiedSize = t, window.log = n, window.logSub = s, window.logUnsub = r), "undefined" != typeof module && module.exports && (module.exports = Juris, module.exports.deepEquals = deepEquals, module.exports.jurisVersion = e, module.exports.jurisLinesOfCode = 2558, module.exports.jurisMinifiedSize = t, module.exports.log = n, module.exports.logSub = s, module.exports.logUnsub = r) }();