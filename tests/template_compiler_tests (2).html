<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TemplateCompiler Unit Tests</title>
    <script src="../src/juris.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background: #f5f7fa;
        }
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .test-header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e2e8f0;
        }
        .test-category {
            margin: 25px 0;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
        }
        .category-header {
            background: #f8fafc;
            padding: 15px 20px;
            font-weight: bold;
            color: #374151;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .test-item {
            padding: 15px 20px;
            border-bottom: 1px solid #f1f5f9;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .test-item:last-child {
            border-bottom: none;
        }
        .test-name {
            flex: 1;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        .test-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }
        .status-pass { background: #d1fae5; color: #065f46; }
        .status-fail { background: #fee2e2; color: #991b1b; }
        .status-running { background: #fef3c7; color: #92400e; }
        .status-pending { background: #e5e7eb; color: #6b7280; }
        
        .test-duration {
            margin-left: 10px;
            font-size: 11px;
            color: #6b7280;
        }
        
        .test-error {
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #991b1b;
        }
        
        .run-controls {
            margin: 20px 0;
            text-align: center;
        }
        
        button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin: 0 5px;
            font-size: 14px;
        }
        
        button:hover { background: #2563eb; }
        button:disabled { background: #9ca3af; cursor: not-allowed; }
        
        .summary {
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }
        
        .code-preview {
            background: #1e293b;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <!-- Test Templates -->
    <template --component="SimpleButton" style="display: none;">
        <script>
            const handleClick = () => setState('clicked', true);
        </script>
        <button onClick="{()=>handleClick()}" className="btn">
            {text:()=>getState('buttonText', 'Click Me')}
        </button>
    </template>

    <template --component="ComplexTodo" style="display: none;">
        <script>
            const toggleComplete = () => {
                const completed = getState(`todos.${props.index}.completed`, false);
                setState(`todos.${props.index}.completed`, !completed);
            };
            
            const deleteItem = () => {
                const todos = getState('todos', []);
                setState('todos', todos.filter((_, i) => i !== props.index));
            };
        </script>
        <div className="{()=>'todo-item' + (getState(`todos.${props.index}.completed`, false) ? ' completed' : '')}">
            <input type="checkbox" checked="{()=>getState(`todos.${props.index}.completed`, false)}" onChange="{()=>toggleComplete()}" />
            <span className="{()=>'todo-text' + (getState(`todos.${props.index}.completed`, false) ? ' completed' : '')}">{text:()=>getState(`todos.${props.index}.text`, '')}</span>
            <button onClick="{()=>deleteItem()}" style="background: #dc3545; color: white;">Delete</button>
            {children:()=>getState('showDetails', false) ? [{DetailPanel: {item: getState(`todos.${props.index}`)}}] : []}
        </div>
    </template>

    <template --component="EmptyComponent" style="display: none;">
        <div></div>
    </template>

    <template --component="NoScript" style="display: none;">
        <span>Static content only</span>
    </template>

    <div class="test-container">
        <div class="test-header">
            <h1>ðŸ§ª TemplateCompiler Unit Tests</h1>
            <p>Comprehensive testing coverage for template parsing, object conversion, and Juris integration</p>
        </div>

        <div class="run-controls">
            <button id="run-all">Run All Tests</button>
            <button id="run-basic">Run Basic Tests</button>
            <button id="run-edge">Run Edge Cases</button>
            <button id="run-integration">Run Integration Tests</button>
            <button id="clear-results">Clear Results</button>
        </div>

        <div id="test-summary" class="summary" style="display: none;">
            <strong>Test Summary:</strong>
            <span id="summary-text"></span>
        </div>

        <div id="test-results"></div>
    </div>

    <script>
        // Include the TemplateCompiler from the provided code
        class TemplateCompiler {
            parseTemplate(template) {
                const name = template.getAttribute('--component');
                const content = template.content;
                
                const script = content.querySelector('script')?.textContent.trim() || '';
                
                const div = document.createElement('div');
                div.appendChild(content.cloneNode(true));
                div.querySelector('script')?.remove();
                const html = div.innerHTML.trim();
                
                return { name, script, html };
            }
            
            htmlToObject(html) {
                const div = document.createElement('div');
                div.innerHTML = html;
                return this.convertElement(div.firstElementChild);
            }
            
            convertElement(element) {
                const obj = {};
                const tag = element.tagName.toLowerCase();
                obj[tag] = {};
                
                // Process attributes
                for (const attr of element.attributes) {
                    let value = attr.value;
                    if (value.startsWith('{') && value.endsWith('}')) {
                        const expr = value.slice(1, -1);
                        obj[tag][attr.name] = { __FUNCTION__: expr };
                    } else {
                        obj[tag][attr.name] = value;
                    }
                }
                
                // Process children
                const children = Array.from(element.childNodes);
                const processedChildren = children
                    .map(child => this.convertNode(child))
                    .filter(child => child !== null);
                
                if (processedChildren.length === 1) {
                    const child = processedChildren[0];
                    if (child && child.__REACTIVE_CHILDREN__) {
                        obj[tag].children = { __FUNCTION__: child.__REACTIVE_CHILDREN__ };
                    } else if (child && child.__REACTIVE_TEXT__) {
                        obj[tag].text = { __FUNCTION__: child.__REACTIVE_TEXT__ };
                    } else if (typeof child === 'string') {
                        obj[tag].text = child;
                    } else if (child) {
                        obj[tag].children = [child];
                    }
                } else if (processedChildren.length > 0) {
                    obj[tag].children = processedChildren;
                }
                
                return obj;
            }
            
            convertNode(node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    const text = node.textContent.trim();
                    if (!text) return null;
                    
                    // Handle {children:()=>[...]} syntax
                    const childrenMatch = text.match(/^\{children:(.+)\}$/s);
                    if (childrenMatch) {
                        return { __REACTIVE_CHILDREN__: childrenMatch[1] };
                    }
                    
                    // Handle {text:()=>...} syntax
                    const textMatch = text.match(/^\{text:(.+)\}$/s);
                    if (textMatch) {
                        return { __REACTIVE_TEXT__: textMatch[1] };
                    }
                    
                    return text;
                }
                
                if (node.nodeType === Node.ELEMENT_NODE) {
                    return this.convertElement(node);
                }
                
                return null;
            }
            
            generateComponent(parsed) {
                const objStr = this.objectToString(this.htmlToObject(parsed.html));
                return `(props, {getState, setState}) => {
${parsed.script}
  return ${objStr};
}`;
            }
            
            objectToString(obj, indent = 0) {
                const spaces = '  '.repeat(indent);
                
                if (obj && obj.__FUNCTION__) {
                    return obj.__FUNCTION__;
                }
                
                if (typeof obj === 'string') {
                    return `'${obj.replace(/'/g, "\\'")}'`;
                }
                
                if (typeof obj === 'number' || typeof obj === 'boolean') {
                    return String(obj);
                }
                
                if (Array.isArray(obj)) {
                    if (obj.length === 0) return '[]';
                    const items = obj.map(item => 
                        spaces + '  ' + this.objectToString(item, indent + 1)
                    ).join(',\n');
                    return '[\n' + items + '\n' + spaces + ']';
                }
                
                if (typeof obj === 'object' && obj !== null) {
                    const keys = Object.keys(obj);
                    if (keys.length === 0) return '{}';
                    
                    const pairs = keys.map(key => {
                        const value = this.objectToString(obj[key], indent + 1);
                        // Handle property names that need quotes
                        const keyStr = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `'${key}'`;
                        return spaces + '  ' + keyStr + ': ' + value;
                    }).join(',\n');
                    
                    return '{\n' + pairs + '\n' + spaces + '}';
                }
                
                return 'null';
            }
        }

        // Test Framework Implementation
        class JurisTestFramework {
            constructor() {
                this.tests = new Map();
                this.results = new Map();
                this.currentTest = null;
                this.assertions = [];
            }

            expect(actual) {
                return {
                    toBe: (expected) => this.assert(actual === expected, `Expected ${actual} to be ${expected}`),
                    toEqual: (expected) => this.assert(JSON.stringify(actual) === JSON.stringify(expected), `Expected ${JSON.stringify(actual)} to equal ${JSON.stringify(expected)}`),
                    toBeTruthy: () => this.assert(!!actual, `Expected ${actual} to be truthy`),
                    toBeFalsy: () => this.assert(!actual, `Expected ${actual} to be falsy`),
                    toContain: (item) => this.assert(actual.includes && actual.includes(item), `Expected ${actual} to contain ${item}`),
                    toBeInstanceOf: (constructor) => this.assert(actual instanceof constructor, `Expected ${actual} to be instance of ${constructor.name}`),
                    toHaveProperty: (property) => this.assert(actual.hasOwnProperty(property), `Expected ${actual} to have property ${property}`),
                    toBeLessThan: (expected) => this.assert(actual < expected, `Expected ${actual} to be less than ${expected}`),
                    toBeGreaterThan: (expected) => this.assert(actual > expected, `Expected ${actual} to be greater than ${expected}`),
                    toBeLessThanOrEqual: (expected) => this.assert(actual <= expected, `Expected ${actual} to be less than or equal to ${expected}`),
                    toBeGreaterThanOrEqual: (expected) => this.assert(actual >= expected, `Expected ${actual} to be greater than or equal to ${expected}`),
                    toBeNull: () => this.assert(actual === null, `Expected ${actual} to be null`),
                    toBeUndefined: () => this.assert(actual === undefined, `Expected ${actual} to be undefined`),
                    toBeDefined: () => this.assert(actual !== undefined, `Expected ${actual} to be defined`),
                    toHaveLength: (length) => this.assert(actual.length === length, `Expected ${actual} to have length ${length}, but got ${actual.length}`),
                    toMatch: (regex) => this.assert(regex.test(actual), `Expected ${actual} to match ${regex}`),
                    toThrow: () => {
                        let threw = false;
                        try {
                            actual();
                        } catch (e) {
                            threw = true;
                        }
                        this.assert(threw, `Expected function to throw`);
                    }
                };
            }

            assert(condition, message) {
                const assertion = { condition, message, passed: condition };
                this.assertions.push(assertion);
                
                if (!condition) {
                    throw new Error(message);
                }
                
                return condition;
            }

            async runTest(testName) {
                const test = this.tests.get(testName);
                if (!test) return;

                this.currentTest = testName;
                this.assertions = [];
                
                const startTime = performance.now();
                let result = {
                    name: testName,
                    status: 'running',
                    duration: 0,
                    assertions: [],
                    error: null
                };

                try {
                    await test.fn();
                    result.status = 'pass';
                    result.assertions = [...this.assertions];
                } catch (error) {
                    result.status = 'fail';
                    result.error = error;
                    result.assertions = [...this.assertions];
                }

                result.duration = performance.now() - startTime;
                this.results.set(testName, result);
                this.currentTest = null;
                
                return result;
            }

            addTest(name, category, fn, code) {
                this.tests.set(name, { name, category, fn, code });
            }

            getTestsByCategory() {
                const categories = {};
                for (const [name, test] of this.tests) {
                    if (!categories[test.category]) {
                        categories[test.category] = [];
                    }
                    categories[test.category].push({ name, ...test });
                }
                return categories;
            }
        }

        // Initialize test framework
        const testFramework = new JurisTestFramework();

        // Test utilities
        function createTestTemplate(componentName, scriptContent, htmlContent) {
            const template = document.createElement('template');
            template.setAttribute('--component', componentName);
            
            const content = document.createDocumentFragment();
            
            if (scriptContent) {
                const script = document.createElement('script');
                script.textContent = scriptContent;
                content.appendChild(script);
            }
            
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;
            while (tempDiv.firstChild) {
                content.appendChild(tempDiv.firstChild);
            }
            
            template.content.appendChild(content);
            return template;
        }

        // ============================================================================
        // BASIC FUNCTIONALITY TESTS
        // ============================================================================

        testFramework.addTest('parseTemplate_basic', 'Basic Functionality', () => {
            const compiler = new TemplateCompiler();
            const template = document.querySelector('template[--component="SimpleButton"]');
            
            const result = compiler.parseTemplate(template);
            
            testFramework.expect(result).toHaveProperty('name');
            testFramework.expect(result).toHaveProperty('script');
            testFramework.expect(result).toHaveProperty('html');
            testFramework.expect(result.name).toBe('SimpleButton');
            testFramework.expect(result.script).toContain('handleClick');
            testFramework.expect(result.html).toContain('button');
        });

        testFramework.addTest('parseTemplate_noScript', 'Basic Functionality', () => {
            const compiler = new TemplateCompiler();
            const template = document.querySelector('template[--component="NoScript"]');
            
            const result = compiler.parseTemplate(template);
            
            testFramework.expect(result.name).toBe('NoScript');
            testFramework.expect(result.script).toBe('');
            testFramework.expect(result.html).toContain('span');
        });

        testFramework.addTest('htmlToObject_simpleElement', 'Basic Functionality', () => {
            const compiler = new TemplateCompiler();
            const html = '<div className="test">Hello</div>';
            
            const result = compiler.htmlToObject(html);
            
            testFramework.expect(result).toHaveProperty('div');
            testFramework.expect(result.div).toHaveProperty('className');
            testFramework.expect(result.div).toHaveProperty('text');
            testFramework.expect(result.div.className).toBe('test');
            testFramework.expect(result.div.text).toBe('Hello');
        });

        testFramework.addTest('htmlToObject_reactiveAttribute', 'Basic Functionality', () => {
            const compiler = new TemplateCompiler();
            const html = '<button onClick="{()=>handleClick()}">Click</button>';
            
            const result = compiler.htmlToObject(html);
            
            testFramework.expect(result.button).toHaveProperty('onClick');
            testFramework.expect(result.button.onClick).toHaveProperty('__FUNCTION__');
            testFramework.expect(result.button.onClick.__FUNCTION__).toBe('()=>handleClick()');
        });

        testFramework.addTest('htmlToObject_reactiveText', 'Basic Functionality', () => {
            const compiler = new TemplateCompiler();
            const html = '<span>{text:()=>getState("message")}</span>';
            
            const result = compiler.htmlToObject(html);
            
            testFramework.expect(result.span).toHaveProperty('text');
            testFramework.expect(result.span.text).toHaveProperty('__FUNCTION__');
            testFramework.expect(result.span.text.__FUNCTION__).toBe('()=>getState("message")');
        });

        testFramework.addTest('htmlToObject_reactiveChildren', 'Basic Functionality', () => {
            const compiler = new TemplateCompiler();
            const html = '<div>{children:()=>getState("items").map(item => ({Item: {item}}))}</div>';
            
            const result = compiler.htmlToObject(html);
            
            testFramework.expect(result.div).toHaveProperty('children');
            testFramework.expect(result.div.children).toHaveProperty('__FUNCTION__');
            testFramework.expect(result.div.children.__FUNCTION__).toContain('getState("items")');
        });

        testFramework.addTest('generateComponent_basic', 'Basic Functionality', () => {
            const compiler = new TemplateCompiler();
            const parsed = {
                name: 'TestComponent',
                script: 'const test = () => console.log("test");',
                html: '<div className="test">Hello</div>'
            };
            
            const result = compiler.generateComponent(parsed);
            
            testFramework.expect(result).toContain('(props, {getState, setState})');
            testFramework.expect(result).toContain('const test = () => console.log("test");');
            testFramework.expect(result).toContain('div: {');
            testFramework.expect(result).toContain("className: 'test'");
        });

        // ============================================================================
        // EDGE CASES TESTS
        // ============================================================================

        testFramework.addTest('parseTemplate_missingComponent', 'Edge Cases', () => {
            const compiler = new TemplateCompiler();
            const template = document.createElement('template');
            
            const result = compiler.parseTemplate(template);
            
            testFramework.expect(result.name).toBeNull();
        });

        testFramework.addTest('htmlToObject_emptyElement', 'Edge Cases', () => {
            const compiler = new TemplateCompiler();
            const html = '<div></div>';
            
            const result = compiler.htmlToObject(html);
            
            testFramework.expect(result).toHaveProperty('div');
            testFramework.expect(Object.keys(result.div)).toHaveLength(0);
        });

        testFramework.addTest('htmlToObject_nestedElements', 'Edge Cases', () => {
            const compiler = new TemplateCompiler();
            const html = '<div><span>Inner</span><p>Text</p></div>';
            
            const result = compiler.htmlToObject(html);
            
            testFramework.expect(result.div).toHaveProperty('children');
            testFramework.expect(result.div.children).toBeInstanceOf(Array);
            testFramework.expect(result.div.children).toHaveLength(2);
            testFramework.expect(result.div.children[0]).toHaveProperty('span');
            testFramework.expect(result.div.children[1]).toHaveProperty('p');
        });

        testFramework.addTest('htmlToObject_complexAttributes', 'Edge Cases', () => {
            const compiler = new TemplateCompiler();
            const html = '<input type="text" value="{()=>getState(`user.${props.id}.name`)}" data-testid="user-input" />';
            
            const result = compiler.htmlToObject(html);
            
            testFramework.expect(result.input.type).toBe('text');
            testFramework.expect(result.input.value.__FUNCTION__).toContain('getState(`user.${props.id}.name`)');
            testFramework.expect(result.input['data-testid']).toBe('user-input');
        });

        testFramework.addTest('htmlToObject_specialCharacters', 'Edge Cases', () => {
            const compiler = new TemplateCompiler();
            const html = '<div title="Test \'quotes\' and &amp; symbols">Content</div>';
            
            const result = compiler.htmlToObject(html);
            
            testFramework.expect(result.div.title).toContain('quotes');
            testFramework.expect(result.div.text).toBe('Content');
        });

        testFramework.addTest('objectToString_complexNesting', 'Edge Cases', () => {
            const compiler = new TemplateCompiler();
            const complexObj = {
                div: {
                    className: { __FUNCTION__: '()=>"test"' },
                    children: [
                        { span: { text: 'Hello' } },
                        { button: { onClick: { __FUNCTION__: '()=>click()' } } }
                    ]
                }
            };
            
            const result = compiler.objectToString(complexObj);
            
            testFramework.expect(result).toContain('()=>"test"');
            testFramework.expect(result).toContain('()=>click()');
            testFramework.expect(result).toContain("text: 'Hello'");
        });

        testFramework.addTest('objectToString_emptyArrays', 'Edge Cases', () => {
            const compiler = new TemplateCompiler();
            const obj = { div: { children: [] } };
            
            const result = compiler.objectToString(obj);
            
            testFramework.expect(result).toContain('children: []');
        });

        testFramework.addTest('convertNode_whitespaceHandling', 'Edge Cases', () => {
            const compiler = new TemplateCompiler();
            const div = document.createElement('div');
            div.innerHTML = '   \n  \t  ';
            const textNode = div.firstChild;
            
            const result = compiler.convertNode(textNode);
            
            testFramework.expect(result).toBeNull();
        });

        // ============================================================================
        // JURIS INTEGRATION TESTS
        // ============================================================================

        testFramework.addTest('jurisIntegration_componentRegistration', 'Juris Integration', () => {
            const compiler = new TemplateCompiler();
            const juris = new Juris({ states: { test: 'value' } });
            
            const template = document.querySelector('template[--component="SimpleButton"]');
            const parsed = compiler.parseTemplate(template);
            const componentCode = compiler.generateComponent(parsed);
            const componentFunction = eval(`(${componentCode})`);
            
            juris.registerComponent('TestButton', componentFunction);
            
            testFramework.expect(juris.componentManager.components.has('TestButton')).toBeTruthy();
        });

        testFramework.addTest('jurisIntegration_componentCreation', 'Juris Integration', () => {
            const compiler = new TemplateCompiler();
            const juris = new Juris({ 
                states: { 
                    buttonText: 'Test Button',
                    clicked: false 
                } 
            });
            
            const template = document.querySelector('template[--component="SimpleButton"]');
            const parsed = compiler.parseTemplate(template);
            const componentCode = compiler.generateComponent(parsed);
            const componentFunction = eval(`(${componentCode})`);
            
            juris.registerComponent('TestButton', componentFunction);
            const component = juris.componentManager.create('TestButton', {});
            
            testFramework.expect(component).toBeDefined();
            testFramework.expect(component.tagName.toLowerCase()).toBe('button');
        });

        testFramework.addTest('jurisIntegration_stateAccess', 'Juris Integration', () => {
            const compiler = new TemplateCompiler();
            const juris = new Juris({ 
                states: { 
                    buttonText: 'Dynamic Text',
                    clicked: false 
                } 
            });
            
            const template = document.querySelector('template[--component="SimpleButton"]');
            const parsed = compiler.parseTemplate(template);
            const componentCode = compiler.generateComponent(parsed);
            const componentFunction = eval(`(${componentCode})`);
            
            juris.registerComponent('TestButton', componentFunction);
            const component = juris.componentManager.create('TestButton', {});
            
            testFramework.expect(component.textContent).toBe('Dynamic Text');
        });

        testFramework.addTest('jurisIntegration_complexComponent', 'Juris Integration', () => {
            const compiler = new TemplateCompiler();
            const juris = new Juris({ 
                states: { 
                    todos: [
                        { text: 'Test todo', completed: false }
                    ]
                } 
            });
            
            const template = document.querySelector('template[--component="ComplexTodo"]');
            const parsed = compiler.parseTemplate(template);
            const componentCode = compiler.generateComponent(parsed);
            const componentFunction = eval(`(${componentCode})`);
            
            juris.registerComponent('TodoItem', componentFunction);
            const component = juris.componentManager.create('TodoItem', { index: 0 });
            
            testFramework.expect(component).toBeDefined();
            testFramework.expect(component.querySelector('input[type="checkbox"]')).toBeDefined();
            testFramework.expect(component.querySelector('.todo-text')).toBeDefined();
        });

        testFramework.addTest('jurisIntegration_eventHandling', 'Juris Integration', async () => {
            const compiler = new TemplateCompiler();
            const juris = new Juris({ 
                states: { 
                    buttonText: 'Click Me',
                    clicked: false 
                } 
            });
            
            const template = document.querySelector('template[--component="SimpleButton"]');
            const parsed = compiler.parseTemplate(template);
            const componentCode = compiler.generateComponent(parsed);
            const componentFunction = eval(`(${componentCode})`);
            
            juris.registerComponent('TestButton', componentFunction);
            const component = juris.componentManager.create('TestButton', {});
            
            // Simulate click
            const clickEvent = new Event('click');
            component.dispatchEvent(clickEvent);
            
            // Wait a bit for state update
            await new Promise(resolve => setTimeout(resolve, 10));
            
            testFramework.expect(juris.getState('clicked')).toBeTruthy();
        });

        testFramework.addTest('jurisIntegration_multipleComponents', 'Juris Integration', () => {
            const compiler = new TemplateCompiler();
            const juris = new Juris({ states: {} });
            
            const templates = ['SimpleButton', 'ComplexTodo', 'EmptyComponent'];
            
            templates.forEach(templateName => {
                const template = document.querySelector(`template[--component="${templateName}"]`);
                if (template) {
                    const parsed = compiler.parseTemplate(template);
                    const componentCode = compiler.generateComponent(parsed);
                    const componentFunction = eval(`(${componentCode})`);
                    juris.registerComponent(templateName, componentFunction);
                }
            });
            
            testFramework.expect(juris.componentManager.components.size).toBeGreaterThanOrEqual(3);
            testFramework.expect(juris.componentManager.components.has('SimpleButton')).toBeTruthy();
            testFramework.expect(juris.componentManager.components.has('ComplexTodo')).toBeTruthy();
            testFramework.expect(juris.componentManager.components.has('EmptyComponent')).toBeTruthy();
        });

        // ============================================================================
        // PERFORMANCE TESTS
        // ============================================================================

        testFramework.addTest('performance_largeBatch', 'Performance', () => {
            const compiler = new TemplateCompiler();
            const startTime = performance.now();
            
            // Create and parse 100 templates
            for (let i = 0; i < 100; i++) {
                const template = createTestTemplate(
                    `Component${i}`,
                    `const handler${i} = () => setState('test${i}', true);`,
                    `<div onClick="{()=>handler${i}()}" className="test-${i}">Component ${i}</div>`
                );
                
                const parsed = compiler.parseTemplate(template);
                const componentCode = compiler.generateComponent(parsed);
                
                testFramework.expect(parsed.name).toBe(`Component${i}`);
                testFramework.expect(componentCode).toContain(`handler${i}`);
            }
            
            const duration = performance.now() - startTime;
            testFramework.expect(duration).toBeLessThan(1000); // Should complete in under 1 second
        });

        testFramework.addTest('performance_complexNesting', 'Performance', () => {
            const compiler = new TemplateCompiler();
            const complexHtml = `
                <div className="level1">
                    <div className="level2" onClick="{()=>handler()}">
                        <div className="level3">
                            <span>{text:()=>getState('nested.deep.value')}</span>
                            <div className="level4">
                                {children:()=>getState('items', []).map((item, index) => ({
                                    ItemComponent: { 
                                        item, 
                                        index, 
                                        onClick: () => selectItem(index),
                                        className: getState('selectedIndex') === index ? 'selected' : 'normal'
                                    }
                                }))}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            const startTime = performance.now();
            const result = compiler.htmlToObject(complexHtml);
            const duration = performance.now() - startTime;
            
            testFramework.expect(result).toHaveProperty('div');
            testFramework.expect(duration).toBeLessThan(50); // Should parse complex structure quickly
        });

        // ============================================================================
        // UI AND TEST RUNNER
        // ============================================================================

        function renderTestResults() {
            const resultsContainer = document.getElementById('test-results');
            const categories = testFramework.getTestsByCategory();
            
            resultsContainer.innerHTML = '';
            
            Object.entries(categories).forEach(([categoryName, tests]) => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'test-category';
                
                const categoryHeader = document.createElement('div');
                categoryHeader.className = 'category-header';
                
                const passed = tests.filter(test => testFramework.results.get(test.name)?.status === 'pass').length;
                const total = tests.length;
                
                categoryHeader.innerHTML = `
                    <span>${categoryName}</span>
                    <span>${passed}/${total} passed</span>
                `;
                
                categoryDiv.appendChild(categoryHeader);
                
                tests.forEach(test => {
                    const testDiv = document.createElement('div');
                    testDiv.className = 'test-item';
                    
                    const result = testFramework.results.get(test.name);
                    const status = result?.status || 'pending';
                    const duration = result?.duration ? `${result.duration.toFixed(2)}ms` : '';
                    
                    testDiv.innerHTML = `
                        <div class="test-name">${test.name}</div>
                        <div class="test-status status-${status}">${status.toUpperCase()}</div>
                        <div class="test-duration">${duration}</div>
                    `;
                    
                    if (result?.error) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'test-error';
                        errorDiv.textContent = result.error.message;
                        testDiv.appendChild(errorDiv);
                    }
                    
                    categoryDiv.appendChild(testDiv);
                });
                
                resultsContainer.appendChild(categoryDiv);
            });
        }

        function updateSummary() {
            const summaryDiv = document.getElementById('test-summary');
            const summaryText = document.getElementById('summary-text');
            
            const allResults = Array.from(testFramework.results.values());
            const passed = allResults.filter(r => r.status === 'pass').length;
            const failed = allResults.filter(r => r.status === 'fail').length;
            const total = allResults.length;
            
            if (total > 0) {
                summaryDiv.style.display = 'block';
                summaryText.textContent = `${passed} passed, ${failed} failed, ${total} total`;
                
                if (failed === 0) {
                    summaryDiv.className = 'summary';
                    summaryDiv.style.background = '#f0fdf4';
                    summaryDiv.style.borderColor = '#bbf7d0';
                } else {
                    summaryDiv.style.background = '#fef2f2';
                    summaryDiv.style.borderColor = '#fecaca';
                }
            }
        }

        async function runTests(category = null) {
            const tests = Array.from(testFramework.tests.values());
            const testsToRun = category ? tests.filter(test => test.category === category) : tests;
            
            for (const test of testsToRun) {
                await testFramework.runTest(test.name);
                renderTestResults();
                updateSummary();
                
                // Small delay to show progress
                await new Promise(resolve => setTimeout(resolve, 10));
            }
        }

        // Event listeners
        document.getElementById('run-all').addEventListener('click', () => runTests());
        document.getElementById('run-basic').addEventListener('click', () => runTests('Basic Functionality'));
        document.getElementById('run-edge').addEventListener('click', () => runTests('Edge Cases'));
        document.getElementById('run-integration').addEventListener('click', () => runTests('Juris Integration'));
        
        document.getElementById('clear-results').addEventListener('click', () => {
            testFramework.results.clear();
            renderTestResults();
            document.getElementById('test-summary').style.display = 'none';
        });

        // Initial render
        renderTestResults();
    </script>
</body>
</html>