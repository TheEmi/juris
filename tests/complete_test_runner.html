<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TemplateCompiler Test Suite - Rewritten</title>
    <script src="../src/juris.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f8fafc;
        }
        
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        
        .test-header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid #e2e8f0;
        }
        
        .test-header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .test-header p {
            font-size: 1.1rem;
            color: #666;
            margin-bottom: 10px;
        }
        
        .migration-notice {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            color: #1565c0;
        }
        
        .migration-notice strong {
            color: #0d47a1;
        }
        
        .run-controls {
            display: flex;
            gap: 10px;
            margin: 30px 0;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            min-width: 120px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .summary {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            border: 1px solid #10b981;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        
        .summary.has-failures {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
            border-color: #ef4444;
        }
        
        .summary-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            display: block;
        }
        
        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .test-category {
            margin: 25px 0;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .category-header {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            padding: 20px;
            font-weight: bold;
            color: #374151;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .category-title {
            font-size: 1.2rem;
        }
        
        .category-stats {
            font-size: 0.9rem;
            color: #6b7280;
        }
        
        .test-item {
            padding: 15px 20px;
            border-bottom: 1px solid #f1f5f9;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
        }
        
        .test-item:hover {
            background-color: #f8fafc;
        }
        
        .test-item:last-child {
            border-bottom: none;
        }
        
        .test-name {
            flex: 1;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            color: #374151;
        }
        
        .test-meta {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .test-status {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            min-width: 80px;
            text-align: center;
            text-transform: uppercase;
        }
        
        .status-pass {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #10b981;
        }
        
        .status-fail {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #ef4444;
        }
        
        .status-running {
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #f59e0b;
            animation: pulse 2s infinite;
        }
        
        .status-pending {
            background: #f3f4f6;
            color: #6b7280;
            border: 1px solid #d1d5db;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .test-duration {
            font-size: 11px;
            color: #6b7280;
            min-width: 60px;
            text-align: right;
        }
        
        .test-error {
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            color: #991b1b;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #059669);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .progress-fill.has-failures {
            background: linear-gradient(90deg, #ef4444, #dc2626);
        }
        
        .filter-controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .filter-button {
            background: white;
            border: 2px solid #e5e7eb;
            color: #6b7280;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .filter-button.active {
            background: #667eea;
            border-color: #667eea;
            color: white;
        }
        
        .test-details {
            margin-top: 10px;
            padding: 10px;
            background: #f8fafc;
            border-radius: 6px;
            font-size: 12px;
            display: none;
        }
        
        .test-details.show {
            display: block;
        }
        
        .assertion-list {
            margin-top: 10px;
        }
        
        .assertion {
            padding: 5px 0;
            border-left: 3px solid #10b981;
            padding-left: 10px;
            margin: 5px 0;
        }
        
        .assertion.failed {
            border-left-color: #ef4444;
            color: #991b1b;
        }
        
        @media (max-width: 768px) {
            .test-container {
                padding: 15px;
            }
            
            .run-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .summary-stats {
                flex-direction: column;
                gap: 15px;
            }
            
            .test-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .test-meta {
                width: 100%;
                justify-content: space-between;
            }
        }
    </style>
</head>
<body>
    <!-- Include the updated templates with data-component attributes -->
    
    <!-- Simple Button Component -->
    <template data-component="SimpleButton" style="display: none;">
        <script>
            const handleClick = () => setState('clicked', true);
        </script>
        <button onClick="{()=>handleClick()}" className="btn">
            {text:()=>getState('buttonText', 'Click Me')}
        </button>
    </template>

    <!-- Complex Todo Component -->
    <template data-component="ComplexTodo" style="display: none;">
        <script>
            const toggleComplete = () => {
                const completed = getState(`todos.${props.index}.completed`, false);
                setState(`todos.${props.index}.completed`, !completed);
            };
            
            const deleteItem = () => {
                const todos = getState('todos', []);
                setState('todos', todos.filter((_, i) => i !== props.index));
            };
        </script>
        <div className="{()=>'todo-item' + (getState(`todos.${props.index}.completed`, false) ? ' completed' : '')}">
            <input type="checkbox" checked="{()=>getState(`todos.${props.index}.completed`, false)}" onChange="{()=>toggleComplete()}" />
            <span className="{()=>'todo-text' + (getState(`todos.${props.index}.completed`, false) ? ' completed' : '')}">{text:()=>getState(`todos.${props.index}.text`, '')}</span>
            <button onClick="{()=>deleteItem()}" style="background: #dc3545; color: white;">Delete</button>
            {children:()=>getState('showDetails', false) ? [{DetailPanel: {item: getState(`todos.${props.index}`)}}] : []}
        </div>
    </template>

    <!-- Empty Component -->
    <template data-component="EmptyComponent" style="display: none;">
        <div></div>
    </template>

    <!-- No Script Component -->
    <template data-component="NoScript" style="display: none;">
        <span>Static content only</span>
    </template>

    <div class="test-container">
        <div class="test-header">
            <h1>🧪 TemplateCompiler Test Suite</h1>
            <p>Comprehensive testing for template parsing, object conversion, and Juris integration</p>
            <div class="migration-notice">
                <strong>✅ Migration Complete:</strong> All tests now use standard HTML5 <code>data-component</code> attributes instead of custom <code>--component</code> attributes for full browser compatibility.
            </div>
        </div>

        <div class="run-controls">
            <button id="run-all">🚀 Run All Tests</button>
            <button id="run-debug">🔍 Debug</button>
            <button id="run-basic">📋 Basic Tests</button>
            <button id="run-edge">⚠️ Edge Cases</button>
            <button id="run-integration">🔗 Integration</button>
            <button id="run-performance">⚡ Performance</button>
            <button id="run-security">🛡️ Security</button>
            <button id="clear-results">🗑️ Clear Results</button>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>

        <div id="test-summary" class="summary" style="display: none;">
            <h3>Test Results Summary</h3>
            <div class="summary-stats">
                <div class="stat">
                    <span class="stat-number" id="total-tests">0</span>
                    <span class="stat-label">Total</span>
                </div>
                <div class="stat">
                    <span class="stat-number" id="passed-tests">0</span>
                    <span class="stat-label">Passed</span>
                </div>
                <div class="stat">
                    <span class="stat-number" id="failed-tests">0</span>
                    <span class="stat-label">Failed</span>
                </div>
                <div class="stat">
                    <span class="stat-number" id="pass-rate">0%</span>
                    <span class="stat-label">Pass Rate</span>
                </div>
            </div>
        </div>

        <div class="filter-controls">
            <button class="filter-button active" data-filter="all">All Tests</button>
            <button class="filter-button" data-filter="passed">Passed Only</button>
            <button class="filter-button" data-filter="failed">Failed Only</button>
            <button class="filter-button" data-filter="pending">Pending</button>
        </div>

        <div id="test-results"></div>
    </div>

    <script>
        // Include the rewritten TemplateCompiler and test framework
        
        // ============================================================================
        // TEMPLATE COMPILER - REWRITTEN FOR data-component
        // ============================================================================
        
        class TemplateCompiler {
            parseTemplate(template) {
                const name = template.getAttribute('data-component');
                if (!name) {
                    console.warn('Template missing data-component attribute');
                    return { name: null, script: '', html: '' };
                }
                
                const content = template.content;
                const script = content.querySelector('script')?.textContent.trim() || '';
                
                const div = document.createElement('div');
                div.appendChild(content.cloneNode(true));
                div.querySelector('script')?.remove();
                const html = div.innerHTML.trim();
                
                return { name, script, html };
            }
            
            htmlToObject(html) {
                const div = document.createElement('div');
                div.innerHTML = html;
                return this.convertElement(div.firstElementChild);
            }
            
            convertElement(element) {
                if (!element) return null;
                
                const obj = {};
                const tag = element.tagName.toLowerCase();
                obj[tag] = {};
                
                // Process attributes
                for (const attr of element.attributes) {
                    let value = attr.value;
                    if (value.startsWith('{') && value.endsWith('}')) {
                        const expr = value.slice(1, -1);
                        obj[tag][attr.name] = { __FUNCTION__: expr };
                    } else {
                        obj[tag][attr.name] = value;
                    }
                }
                
                // Process children
                const children = Array.from(element.childNodes);
                const processedChildren = children
                    .map(child => this.convertNode(child))
                    .filter(child => child !== null);
                
                if (processedChildren.length === 1) {
                    const child = processedChildren[0];
                    if (child && child.__REACTIVE_CHILDREN__) {
                        obj[tag].children = { __FUNCTION__: child.__REACTIVE_CHILDREN__ };
                    } else if (child && child.__REACTIVE_TEXT__) {
                        obj[tag].text = { __FUNCTION__: child.__REACTIVE_TEXT__ };
                    } else if (typeof child === 'string') {
                        obj[tag].text = child;
                    } else if (child) {
                        obj[tag].children = [child];
                    }
                } else if (processedChildren.length > 0) {
                    obj[tag].children = processedChildren;
                }
                
                return obj;
            }
            
            convertNode(node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    const text = node.textContent.trim();
                    if (!text) return null;
                    
                    // Handle {children:()=>[...]} syntax
                    const childrenMatch = text.match(/^\{children:(.+)\}$/s);
                    if (childrenMatch) {
                        return { __REACTIVE_CHILDREN__: childrenMatch[1] };
                    }
                    
                    // Handle {text:()=>...} syntax
                    const textMatch = text.match(/^\{text:(.+)\}$/s);
                    if (textMatch) {
                        return { __REACTIVE_TEXT__: textMatch[1] };
                    }
                    
                    return text;
                }
                
                if (node.nodeType === Node.ELEMENT_NODE) {
                    return this.convertElement(node);
                }
                
                return null;
            }
            
            generateComponent(parsed) {
                if (!parsed.name) {
                    throw new Error('Cannot generate component without name');
                }
                
                const objStr = this.objectToString(this.htmlToObject(parsed.html));
                return '(props, {getState, setState}) => {\n' +
                       parsed.script + '\n' +
                       '  return ' + objStr + ';\n' +
                       '}';
            }
            
            objectToString(obj, indent = 0) {
                const spaces = '  '.repeat(indent);
                
                if (obj && obj.__FUNCTION__) {
                    return obj.__FUNCTION__;
                }
                
                if (typeof obj === 'string') {
                    return `'${obj.replace(/'/g, "\\'")}'`;
                }
                
                if (typeof obj === 'number' || typeof obj === 'boolean') {
                    return String(obj);
                }
                
                if (Array.isArray(obj)) {
                    if (obj.length === 0) return '[]';
                    const items = obj.map(item => 
                        spaces + '  ' + this.objectToString(item, indent + 1)
                    ).join(',\n');
                    return '[\n' + items + '\n' + spaces + ']';
                }
                
                if (typeof obj === 'object' && obj !== null) {
                    const keys = Object.keys(obj);
                    if (keys.length === 0) return '{}';
                    
                    const pairs = keys.map(key => {
                        const value = this.objectToString(obj[key], indent + 1);
                        const keyStr = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `'${key}'`;
                        return spaces + '  ' + keyStr + ': ' + value;
                    }).join(',\n');
                    
                    return '{\n' + pairs + '\n' + spaces + '}';
                }
                
                return 'null';
            }
            
            // Utility method to create component function safely
            createComponentFunction(componentCode) {
                try {
                    // Split the component code safely
                    const parts = componentCode.split('return ');
                    const scriptPart = parts[0] || '';
                    const returnPart = parts.slice(1).join('return ') || '{}';
                    
                    return new Function('props', 'context', 
                        'const {getState, setState} = context;\n' +
                        scriptPart + '\n' +
                        'return ' + returnPart
                    );
                } catch (error) {
                    console.error('Failed to create component function:', error);
                    return () => ({ div: { text: 'Component Error' } });
                }
            }
        }

        // ============================================================================
        // TEST FRAMEWORK - ENHANCED
        // ============================================================================
        
        class JurisTestFramework {
            constructor() {
                this.tests = new Map();
                this.results = new Map();
                this.currentTest = null;
                this.assertions = [];
                this.isRunning = false;
                this.filter = 'all';
            }

            expect(actual) {
                return {
                    toBe: (expected) => this.assert(actual === expected, 
                        `Expected ${this._format(actual)} to be ${this._format(expected)}`),
                    toEqual: (expected) => this.assert(this._deepEqual(actual, expected), 
                        `Expected ${this._format(actual)} to equal ${this._format(expected)}`),
                    toBeTruthy: () => this.assert(!!actual, 
                        `Expected ${this._format(actual)} to be truthy`),
                    toBeFalsy: () => this.assert(!actual, 
                        `Expected ${this._format(actual)} to be falsy`),
                    toContain: (item) => this.assert(
                        actual && actual.includes && actual.includes(item), 
                        `Expected ${this._format(actual)} to contain ${this._format(item)}`),
                    toBeInstanceOf: (constructor) => this.assert(actual instanceof constructor, 
                        `Expected ${this._format(actual)} to be instance of ${constructor.name}`),
                    toHaveProperty: (property) => this.assert(
                        actual && actual.hasOwnProperty && actual.hasOwnProperty(property), 
                        `Expected ${this._format(actual)} to have property ${property}`),
                    toBeLessThan: (expected) => this.assert(actual < expected, 
                        `Expected ${actual} to be less than ${expected}`),
                    toBeGreaterThan: (expected) => this.assert(actual > expected, 
                        `Expected ${actual} to be greater than ${expected}`),
                    toBeLessThanOrEqual: (expected) => this.assert(actual <= expected, 
                        `Expected ${actual} to be less than or equal to ${expected}`),
                    toBeGreaterThanOrEqual: (expected) => this.assert(actual >= expected, 
                        `Expected ${actual} to be greater than or equal to ${expected}`),
                    toBeNull: () => this.assert(actual === null, 
                        `Expected ${this._format(actual)} to be null`),
                    toBeUndefined: () => this.assert(actual === undefined, 
                        `Expected ${this._format(actual)} to be undefined`),
                    toBeDefined: () => this.assert(actual !== undefined, 
                        `Expected ${this._format(actual)} to be defined`),
                    toHaveLength: (length) => this.assert(
                        actual && typeof actual.length === 'number' && actual.length === length, 
                        `Expected ${this._format(actual)} to have length ${length}, but got ${actual?.length}`),
                    toMatch: (regex) => this.assert(regex.test(actual), 
                        `Expected ${this._format(actual)} to match ${regex}`),
                    toThrow: (expectedError) => {
                        let threw = false;
                        let thrownError = null;
                        try {
                            actual();
                        } catch (e) {
                            threw = true;
                            thrownError = e;
                        }
                        if (expectedError) {
                            this.assert(threw && thrownError.message.includes(expectedError), 
                                `Expected function to throw error containing "${expectedError}", but got: ${thrownError?.message || 'no error'}`);
                        } else {
                            this.assert(threw, `Expected function to throw an error`);
                        }
                    },
                    not: {
                        toThrow: () => {
                            let threw = false;
                            try {
                                actual();
                            } catch (e) {
                                threw = true;
                            }
                            this.assert(!threw, `Expected function not to throw`);
                        }
                    }
                };
            }

            _format(value) {
                if (value === null) return 'null';
                if (value === undefined) return 'undefined';
                if (typeof value === 'string') return `"${value}"`;
                if (typeof value === 'function') return '[Function]';
                if (typeof value === 'object') {
                    try {
                        return JSON.stringify(value, null, 0);
                    } catch (e) {
                        return '[Object]';
                    }
                }
                return String(value);
            }

            _deepEqual(a, b) {
                if (a === b) return true;
                if (a == null || b == null) return false;
                if (typeof a !== typeof b) return false;
                
                if (typeof a === 'object') {
                    if (Array.isArray(a) !== Array.isArray(b)) return false;
                    
                    const keysA = Object.keys(a);
                    const keysB = Object.keys(b);
                    
                    if (keysA.length !== keysB.length) return false;
                    
                    return keysA.every(key => 
                        keysB.includes(key) && this._deepEqual(a[key], b[key])
                    );
                }
                
                return false;
            }

            assert(condition, message) {
                const assertion = { condition, message, passed: condition };
                this.assertions.push(assertion);
                
                if (!condition) {
                    throw new Error(message);
                }
                
                return condition;
            }

            async runTest(testName) {
                const test = this.tests.get(testName);
                if (!test) return;

                this.currentTest = testName;
                this.assertions = [];
                
                const startTime = performance.now();
                let result = {
                    name: testName,
                    status: 'running',
                    duration: 0,
                    assertions: [],
                    error: null
                };

                try {
                    await test.fn();
                    result.status = 'pass';
                    result.assertions = [...this.assertions];
                } catch (error) {
                    result.status = 'fail';
                    result.error = error;
                    result.assertions = [...this.assertions];
                }

                result.duration = performance.now() - startTime;
                this.results.set(testName, result);
                this.currentTest = null;
                
                return result;
            }

            addTest(name, category, fn) {
                this.tests.set(name, { name, category, fn });
            }

            getTestsByCategory() {
                const categories = {};
                for (const [name, test] of this.tests) {
                    if (!categories[test.category]) {
                        categories[test.category] = [];
                    }
                    categories[test.category].push({ name, ...test });
                }
                return categories;
            }

            clearResults() {
                this.results.clear();
            }

            getStats() {
                const allResults = Array.from(this.results.values());
                const passed = allResults.filter(r => r.status === 'pass').length;
                const failed = allResults.filter(r => r.status === 'fail').length;
                
                return {
                    total: allResults.length,
                    passed,
                    failed,
                    passRate: allResults.length ? (passed / allResults.length * 100).toFixed(1) : 0
                };
            }

            setFilter(filter) {
                this.filter = filter;
                this.renderResults();
            }

            renderResults() {
                const resultsContainer = document.getElementById('test-results');
                const categories = this.getTestsByCategory();
                
                resultsContainer.innerHTML = '';
                
                Object.entries(categories).forEach(([categoryName, tests]) => {
                    const categoryDiv = document.createElement('div');
                    categoryDiv.className = 'test-category';
                    
                    const filteredTests = tests.filter(test => {
                        const result = this.results.get(test.name);
                        switch (this.filter) {
                            case 'passed':
                                return result?.status === 'pass';
                            case 'failed':
                                return result?.status === 'fail';
                            case 'pending':
                                return !result || result.status === 'pending';
                            default:
                                return true;
                        }
                    });

                    if (filteredTests.length === 0) return;
                    
                    const passed = filteredTests.filter(test => this.results.get(test.name)?.status === 'pass').length;
                    const total = filteredTests.length;
                    
                    const categoryHeader = document.createElement('div');
                    categoryHeader.className = 'category-header';
                    categoryHeader.innerHTML = 
                        '<span class="category-title">' + categoryName + '</span>' +
                        '<span class="category-stats">' + passed + '/' + total + ' passed</span>';
                    
                    categoryDiv.appendChild(categoryHeader);
                    
                    filteredTests.forEach(test => {
                        const testDiv = document.createElement('div');
                        testDiv.className = 'test-item';
                        
                        const result = this.results.get(test.name);
                        const status = result?.status || 'pending';
                        const duration = result?.duration ? `${result.duration.toFixed(2)}ms` : '';
                        
                        testDiv.innerHTML = 
                            '<div class="test-name">' + test.name + '</div>' +
                            '<div class="test-meta">' +
                                '<div class="test-status status-' + status + '">' + status + '</div>' +
                                '<div class="test-duration">' + duration + '</div>' +
                            '</div>';
                        
                        if (result && result.error) {
                            const errorDiv = document.createElement('div');
                            errorDiv.className = 'test-error';
                            errorDiv.textContent = result.error.message;
                            testDiv.appendChild(errorDiv);
                        }

                        if (result && result.assertions && result.assertions.length > 0) {
                            const detailsDiv = document.createElement('div');
                            detailsDiv.className = 'test-details';
                            
                            let assertionHTML = '<strong>Assertions (' + result.assertions.length + '):</strong>' +
                                               '<div class="assertion-list">';
                            
                            result.assertions.forEach(assertion => {
                                assertionHTML += '<div class="assertion ' + (assertion.passed ? 'passed' : 'failed') + '">' +
                                               (assertion.passed ? '✓' : '✗') + ' ' + assertion.message +
                                               '</div>';
                            });
                            
                            assertionHTML += '</div>';
                            detailsDiv.innerHTML = assertionHTML;
                            
                            testDiv.appendChild(detailsDiv);

                            testDiv.addEventListener('click', () => {
                                detailsDiv.classList.toggle('show');
                            });
                            testDiv.style.cursor = 'pointer';
                        }
                        
                        categoryDiv.appendChild(testDiv);
                    });
                    
                    resultsContainer.appendChild(categoryDiv);
                });
            }
        }

        // ============================================================================
        // TEST UTILITIES
        // ============================================================================
        
        // ============================================================================
        // TEST UTILITIES - MOVED TO TOP
        // ============================================================================
        
        function createTestTemplate(componentName, scriptContent, htmlContent) {
            const template = document.createElement('template');
            template.setAttribute('data-component', componentName);
            
            const content = document.createDocumentFragment();
            
            if (scriptContent) {
                const script = document.createElement('script');
                script.textContent = scriptContent;
                content.appendChild(script);
            }
            
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;
            while (tempDiv.firstChild) {
                content.appendChild(tempDiv.firstChild);
            }
            
            template.content.appendChild(content);
            return template;
        }

        // ============================================================================
        // DEBUG AND VALIDATION TESTS
        // ============================================================================
        
        testFramework.addTest('debug_templateAvailability', 'Debug', () => {
            const templates = document.querySelectorAll('template[data-component]');
            testFramework.expect(templates.length).toBeGreaterThan(0);
            
            const simpleButton = document.querySelector('template[data-component="SimpleButton"]');
            testFramework.expect(simpleButton).toBeDefined();
            testFramework.expect(simpleButton).not.toBeNull();
            
            if (simpleButton) {
                const compiler = new TemplateCompiler();
                const parsed = compiler.parseTemplate(simpleButton);
                testFramework.expect(parsed.name).toBe('SimpleButton');
                testFramework.expect(parsed.script).toContain('handleClick');
                
                console.log('Debug - Parsed template:', parsed);
            }
        });
        
        testFramework.addTest('debug_jurisCreation', 'Debug', () => {
            const juris = new Juris({ states: { test: 'value' } });
            testFramework.expect(juris).toBeDefined();
            testFramework.expect(juris.componentManager).toBeDefined();
            testFramework.expect(typeof juris.componentManager.create).toBe('function');
            
            console.log('Debug - Juris instance:', juris);
        });

        // ============================================================================
        // ALL TESTS - LOADED FROM PREVIOUS ARTIFACTS
        // ============================================================================
        
        // Initialize the test framework
        const testFramework = new JurisTestFramework();

        // ============================================================================
        // BASIC FUNCTIONALITY TESTS
        // ============================================================================

        testFramework.addTest('parseTemplate_basic', 'Basic Functionality', () => {
            const compiler = new TemplateCompiler();
            const template = document.querySelector('template[data-component="SimpleButton"]');
            
            const result = compiler.parseTemplate(template);
            
            testFramework.expect(result).toHaveProperty('name');
            testFramework.expect(result).toHaveProperty('script');
            testFramework.expect(result).toHaveProperty('html');
            testFramework.expect(result.name).toBe('SimpleButton');
            testFramework.expect(result.script).toContain('handleClick');
            testFramework.expect(result.html).toContain('button');
        });

        testFramework.addTest('parseTemplate_noScript', 'Basic Functionality', () => {
            const compiler = new TemplateCompiler();
            const template = document.querySelector('template[data-component="NoScript"]');
            
            const result = compiler.parseTemplate(template);
            
            testFramework.expect(result.name).toBe('NoScript');
            testFramework.expect(result.script).toBe('');
            testFramework.expect(result.html).toContain('span');
        });

        testFramework.addTest('parseTemplate_missingAttribute', 'Basic Functionality', () => {
            const compiler = new TemplateCompiler();
            const template = document.createElement('template');
            // No data-component attribute
            
            const result = compiler.parseTemplate(template);
            
            testFramework.expect(result.name).toBeNull();
            testFramework.expect(result.script).toBe('');
            testFramework.expect(result.html).toBe('');
        });

        testFramework.addTest('htmlToObject_simpleElement', 'Basic Functionality', () => {
            const compiler = new TemplateCompiler();
            const html = '<div className="test">Hello</div>';
            
            const result = compiler.htmlToObject(html);
            
            testFramework.expect(result).toHaveProperty('div');
            testFramework.expect(result.div).toHaveProperty('classname'); // Note: HTML normalizes to lowercase
            testFramework.expect(result.div).toHaveProperty('text');
            testFramework.expect(result.div.classname).toBe('test'); // lowercase
            testFramework.expect(result.div.text).toBe('Hello');
        });

        testFramework.addTest('htmlToObject_reactiveAttribute', 'Basic Functionality', () => {
            const compiler = new TemplateCompiler();
            const html = '<button onClick="{()=>handleClick()}">Click</button>';
            
            const result = compiler.htmlToObject(html);
            
            testFramework.expect(result.button).toHaveProperty('onclick'); // Note: HTML normalizes to lowercase
            testFramework.expect(result.button.onclick).toHaveProperty('__FUNCTION__');
            testFramework.expect(result.button.onclick.__FUNCTION__).toBe('()=>handleClick()');
        });

        testFramework.addTest('htmlToObject_reactiveText', 'Basic Functionality', () => {
            const compiler = new TemplateCompiler();
            const html = '<span>{text:()=>getState("message")}</span>';
            
            const result = compiler.htmlToObject(html);
            
            testFramework.expect(result.span).toHaveProperty('text');
            testFramework.expect(result.span.text).toHaveProperty('__FUNCTION__');
            testFramework.expect(result.span.text.__FUNCTION__).toBe('()=>getState("message")');
        });

        testFramework.addTest('htmlToObject_reactiveChildren', 'Basic Functionality', () => {
            const compiler = new TemplateCompiler();
            const html = '<div>{children:()=>getState("items").map(item => ({Item: {item}}))}</div>';
            
            const result = compiler.htmlToObject(html);
            
            testFramework.expect(result.div).toHaveProperty('children');
            testFramework.expect(result.div.children).toHaveProperty('__FUNCTION__');
            testFramework.expect(result.div.children.__FUNCTION__).toContain('getState("items")');
        });

        testFramework.addTest('generateComponent_basic', 'Basic Functionality', () => {
            const compiler = new TemplateCompiler();
            const parsed = {
                name: 'TestComponent',
                script: 'const test = () => console.log("test");',
                html: '<div className="test">Hello</div>'
            };
            
            const result = compiler.generateComponent(parsed);
            
            testFramework.expect(result).toContain('(props, {getState, setState})');
            testFramework.expect(result).toContain('const test = () => console.log("test");');
            testFramework.expect(result).toContain('div: {');
            testFramework.expect(result).toContain("classname: 'test'"); // HTML normalizes to lowercase
        });

        testFramework.addTest('generateComponent_missingName', 'Basic Functionality', () => {
            const compiler = new TemplateCompiler();
            const parsed = {
                name: null,
                script: 'const test = true;',
                html: '<div>Test</div>'
            };
            
            testFramework.expect(() => {
                compiler.generateComponent(parsed);
            }).toThrow('Cannot generate component without name');
        });

        // ============================================================================
        // EDGE CASES TESTS
        // ============================================================================

        testFramework.addTest('htmlToObject_emptyElement', 'Edge Cases', () => {
            const compiler = new TemplateCompiler();
            const html = '<div></div>';
            
            const result = compiler.htmlToObject(html);
            
            testFramework.expect(result).toHaveProperty('div');
            testFramework.expect(Object.keys(result.div)).toHaveLength(0);
        });

        testFramework.addTest('htmlToObject_nestedElements', 'Edge Cases', () => {
            const compiler = new TemplateCompiler();
            const html = '<div><span>Inner</span><p>Text</p></div>';
            
            const result = compiler.htmlToObject(html);
            
            testFramework.expect(result.div).toHaveProperty('children');
            testFramework.expect(result.div.children).toBeInstanceOf(Array);
            testFramework.expect(result.div.children).toHaveLength(2);
            testFramework.expect(result.div.children[0]).toHaveProperty('span');
            testFramework.expect(result.div.children[1]).toHaveProperty('p');
        });

        testFramework.addTest('htmlToObject_complexAttributes', 'Edge Cases', () => {
            const compiler = new TemplateCompiler();
            const html = '<input type="text" value="{()=>getState(\'user.name\')}" data-testid="user-input" />';
            
            const result = compiler.htmlToObject(html);
            
            testFramework.expect(result.input.type).toBe('text');
            testFramework.expect(result.input.value.__FUNCTION__).toContain('getState(\'user.name\')');
            testFramework.expect(result.input['data-testid']).toBe('user-input');
        });

        testFramework.addTest('htmlToObject_malformedHtml', 'Edge Cases', () => {
            const compiler = new TemplateCompiler();
            
            // This should not throw, but handle gracefully
            testFramework.expect(() => {
                const html = '<div><span>Unclosed div';
                const result = compiler.htmlToObject(html);
                // Browser will auto-close tags, so result should still be valid
                testFramework.expect(result).toBeDefined();
            }).not.toThrow();
        });

        // ============================================================================
        // JURIS INTEGRATION TESTS
        // ============================================================================

        testFramework.addTest('jurisIntegration_componentRegistration', 'Juris Integration', () => {
            const compiler = new TemplateCompiler();
            const juris = new Juris({ states: { test: 'value' } });
            
            const template = document.querySelector('template[data-component="SimpleButton"]');
            const parsed = compiler.parseTemplate(template);
            const componentCode = compiler.generateComponent(parsed);
            const componentFunction = compiler.createComponentFunction(componentCode);
            
            juris.registerComponent('TestButton', componentFunction);
            
            testFramework.expect(juris.componentManager.components.has('TestButton')).toBeTruthy();
        });

        testFramework.addTest('jurisIntegration_componentCreation', 'Juris Integration', () => {
            const compiler = new TemplateCompiler();
            const juris = new Juris({ 
                states: { 
                    buttonText: 'Test Button',
                    clicked: false 
                } 
            });
            
            const template = document.querySelector('template[data-component="SimpleButton"]');
            if (!template) {
                testFramework.expect(false).toBeTruthy(); // Fail if template not found
                return;
            }
            
            const parsed = compiler.parseTemplate(template);
            const componentCode = compiler.generateComponent(parsed);
            const componentFunction = compiler.createComponentFunction(componentCode);
            
            juris.registerComponent('TestButton', componentFunction);
            const component = juris.componentManager.create('TestButton', {});
            
            testFramework.expect(component).toBeDefined();
            testFramework.expect(component).not.toBeNull();
            if (component) {
                testFramework.expect(component.tagName.toLowerCase()).toBe('button');
            }
        });

        testFramework.addTest('jurisIntegration_stateAccess', 'Juris Integration', () => {
            const compiler = new TemplateCompiler();
            const juris = new Juris({ 
                states: { 
                    buttonText: 'Dynamic Text',
                    clicked: false 
                } 
            });
            
            const template = document.querySelector('template[data-component="SimpleButton"]');
            if (!template) {
                testFramework.expect(false).toBeTruthy(); // Fail if template not found
                return;
            }
            
            const parsed = compiler.parseTemplate(template);
            const componentCode = compiler.generateComponent(parsed);
            const componentFunction = compiler.createComponentFunction(componentCode);
            
            juris.registerComponent('TestButton', componentFunction);
            const component = juris.componentManager.create('TestButton', {});
            
            testFramework.expect(component).toBeDefined();
            testFramework.expect(component).not.toBeNull();
            if (component) {
                testFramework.expect(component.textContent).toBe('Dynamic Text');
            }
        });

        testFramework.addTest('jurisIntegration_eventHandling', 'Juris Integration', async () => {
            const compiler = new TemplateCompiler();
            const juris = new Juris({ 
                states: { 
                    buttonText: 'Click Me',
                    clicked: false 
                } 
            });
            
            const template = document.querySelector('template[data-component="SimpleButton"]');
            if (!template) {
                testFramework.expect(false).toBeTruthy(); // Fail if template not found
                return;
            }
            
            const parsed = compiler.parseTemplate(template);
            const componentCode = compiler.generateComponent(parsed);
            const componentFunction = compiler.createComponentFunction(componentCode);
            
            juris.registerComponent('TestButton', componentFunction);
            const component = juris.componentManager.create('TestButton', {});
            
            testFramework.expect(component).toBeDefined();
            testFramework.expect(component).not.toBeNull();
            
            if (component) {
                // Simulate click
                const clickEvent = new Event('click');
                component.dispatchEvent(clickEvent);
                
                // Wait a bit for state update
                await new Promise(resolve => setTimeout(resolve, 10));
                
                testFramework.expect(juris.getState('clicked')).toBeTruthy();
            }
        });

        // ============================================================================
        // PERFORMANCE TESTS
        // ============================================================================

        testFramework.addTest('performance_largeBatch', 'Performance', () => {
            const compiler = new TemplateCompiler();
            const startTime = performance.now();
            
            // Create and parse 100 templates
            for (let i = 0; i < 100; i++) {
                const template = createTestTemplate(
                    'Component' + i,
                    'const handler' + i + ' = () => setState(\'test' + i + '\', true);',
                    '<div onClick="{()=>handler' + i + '()}" className="test-' + i + '">Component ' + i + '</div>'
                );
                
                const parsed = compiler.parseTemplate(template);
                const componentCode = compiler.generateComponent(parsed);
                
                testFramework.expect(parsed.name).toBe('Component' + i);
                testFramework.expect(componentCode).toContain('handler' + i);
            }
            
            const duration = performance.now() - startTime;
            testFramework.expect(duration).toBeLessThan(1000); // Should complete in under 1 second
        });

        testFramework.addTest('performance_complexNesting', 'Performance', () => {
            const compiler = new TemplateCompiler();
            const complexHtml = `
                <div className="level1">
                    <div className="level2" onClick="{()=>handler()}">
                        <div className="level3">
                            <span>{text:()=>getState('nested.deep.value')}</span>
                            <div className="level4">
                                {children:()=>getState('items', []).map((item, index) => ({
                                    ItemComponent: { 
                                        item: item, 
                                        index: index, 
                                        onClick: () => selectItem(index),
                                        className: getState('selectedIndex') === index ? 'selected' : 'normal'
                                    }
                                }))}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            const startTime = performance.now();
            const result = compiler.htmlToObject(complexHtml);
            const duration = performance.now() - startTime;
            
            testFramework.expect(result).toHaveProperty('div');
            testFramework.expect(duration).toBeLessThan(50); // Should parse complex structure quickly
        });

        // ============================================================================
        // SECURITY TESTS
        // ============================================================================

        testFramework.addTest('security_htmlInjection', 'Security', () => {
            const compiler = new TemplateCompiler();
            
            // Test that HTML injection in component name is handled
            const maliciousName = '<script>alert("xss")<\/script>';
            const template = createTestTemplate(maliciousName, '', '<div>Safe</div>');
            
            const parsed = compiler.parseTemplate(template);
            testFramework.expect(parsed.name).toBe(maliciousName); // Name is preserved as-is
            
            // But when used in HTML context, it should be escaped
            const componentCode = compiler.generateComponent({
                name: 'SafeComponent',
                script: '',
                html: '<div>Safe content</div>'
            });
            
            testFramework.expect(componentCode).not.toContain('<script>');
        });

        testFramework.addTest('security_scriptInjection', 'Security', () => {
            const compiler = new TemplateCompiler();
            
            // Malicious script content
            const maliciousScript = `
                // This could be malicious
                console.log('This is preserved');
                const legitimate = true;
            `;
            
            const template = createTestTemplate('SecurityTest', maliciousScript, '<div>Content</div>');
            const parsed = compiler.parseTemplate(template);
            
            // Script should be preserved (it's up to the execution context to validate)
            testFramework.expect(parsed.script).toContain('legitimate');
            testFramework.expect(parsed.script).toContain('console.log');
            
            // But createComponentFunction should handle errors gracefully
            const componentCode = compiler.generateComponent(parsed);
            testFramework.expect(typeof componentCode).toBe('string');
            
            // The componentFunction creation should not execute the malicious code
            const componentFunction = compiler.createComponentFunction(componentCode);
            testFramework.expect(typeof componentFunction).toBe('function');
        });

        // ============================================================================
        // UI AND TEST RUNNER
        // ============================================================================

        function updateSummary() {
            const summaryDiv = document.getElementById('test-summary');
            const stats = testFramework.getStats();
            
            if (stats.total > 0) {
                summaryDiv.style.display = 'block';
                
                document.getElementById('total-tests').textContent = stats.total;
                document.getElementById('passed-tests').textContent = stats.passed;
                document.getElementById('failed-tests').textContent = stats.failed;
                document.getElementById('pass-rate').textContent = stats.passRate + '%';
                
                // Update progress bar
                const progressFill = document.getElementById('progress-fill');
                const percentage = (stats.passed / stats.total) * 100;
                progressFill.style.width = percentage + '%';
                
                if (stats.failed > 0) {
                    summaryDiv.classList.add('has-failures');
                    progressFill.classList.add('has-failures');
                } else {
                    summaryDiv.classList.remove('has-failures');
                    progressFill.classList.remove('has-failures');
                }
            }
        }

        async function runTests(category = null) {
            if (testFramework.isRunning) return;
            
            testFramework.isRunning = true;
            const tests = Array.from(testFramework.tests.values());
            const testsToRun = category ? tests.filter(test => test.category === category) : tests;
            
            // Disable buttons during test run
            document.querySelectorAll('.run-controls button').forEach(btn => btn.disabled = true);
            
            for (const test of testsToRun) {
                await testFramework.runTest(test.name);
                testFramework.renderResults();
                updateSummary();
                
                // Small delay to show progress
                await new Promise(resolve => setTimeout(resolve, 5));
            }
            
            // Re-enable buttons
            document.querySelectorAll('.run-controls button').forEach(btn => btn.disabled = false);
            testFramework.isRunning = false;
        }

        // Event listeners
        document.getElementById('run-all').addEventListener('click', () => runTests());
        document.getElementById('run-debug').addEventListener('click', () => runTests('Debug'));
        document.getElementById('run-basic').addEventListener('click', () => runTests('Basic Functionality'));
        document.getElementById('run-edge').addEventListener('click', () => runTests('Edge Cases'));
        document.getElementById('run-integration').addEventListener('click', () => runTests('Juris Integration'));
        document.getElementById('run-performance').addEventListener('click', () => runTests('Performance'));
        document.getElementById('run-security').addEventListener('click', () => runTests('Security'));
        
        document.getElementById('clear-results').addEventListener('click', () => {
            testFramework.clearResults();
            testFramework.renderResults();
            document.getElementById('test-summary').style.display = 'none';
            document.getElementById('progress-fill').style.width = '0%';
        });

        // Filter controls
        document.querySelectorAll('.filter-button').forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('.filter-button').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                const filter = button.getAttribute('data-filter');
                testFramework.setFilter(filter);
            });
        });

        // Initial render
        testFramework.renderResults();
        
        // Auto-run basic tests on load
        setTimeout(() => {
            console.log('🚀 Running basic tests automatically...');
            runTests('Basic Functionality');
        }, 1000);
    </script>
</body>
</html>