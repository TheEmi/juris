<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Juris Animations - Extended Collection</title>
    <script src="../src/juris.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: white;
            overflow-x: hidden;
        }

        .demo-section {
            margin-bottom: 80px;
            padding: 25px;
            border-radius: 15px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls {
            margin-bottom: 25px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: flex-end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 120px;
        }

        .control-group label {
            font-size: 11px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        button {
            padding: 10px 18px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        button.active {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
        }

        input[type="range"] {
            width: 140px;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
        }

        input[type="color"] {
            width: 50px;
            height: 35px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        .demo-container {
            position: relative;
            height: 350px;
            border: 2px dashed rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            overflow: hidden;
            background: radial-gradient(circle at 30% 30%, rgba(102, 126, 234, 0.1), transparent 50%),
                        radial-gradient(circle at 70% 70%, rgba(255, 107, 107, 0.1), transparent 50%),
                        #0f0f0f;
        }

        h1 {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #ff6b6b 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        h2 {
            color: #667eea;
            margin-top: 0;
            font-size: 1.8rem;
        }

        .subtitle {
            text-align: center;
            opacity: 0.7;
            margin-bottom: 40px;
            font-size: 1.1rem;
        }

        .value-display {
            font-size: 12px;
            opacity: 0.8;
            font-weight: 600;
            color: #667eea;
        }

        .fps-counter {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
            color: #4ecdc4;
        }
    </style>
</head>
<body>
    <div class="fps-counter" id="fps-counter">FPS: 60</div>
    
    <h1>Juris Computational Style Showcase</h1>
    <p class="subtitle">Advanced animations, physics simulations, and visual effects using reactive DOM styles</p>

    <!-- Demo 1: Gravitational N-Body System -->
    <div class="demo-section">
        <h2>ðŸŒŒ Gravitational N-Body System</h2>
        <div class="controls">
            <div class="control-group">
                <label>Bodies</label>
                <input type="range" id="nbody-count" min="3" max="12" step="1" value="6">
                <span class="value-display" id="nbody-count-val">6</span>
            </div>
            <div class="control-group">
                <label>Gravity</label>
                <input type="range" id="gravity-strength" min="10" max="200" step="10" value="80">
                <span class="value-display" id="gravity-val">80</span>
            </div>
            <div class="control-group">
                <label>Time Scale</label>
                <input type="range" id="time-scale" min="0.1" max="3" step="0.1" value="1">
                <span class="value-display" id="time-scale-val">1</span>
            </div>
            <div class="control-group">
                <label>Trails</label>
                <button id="trails-toggle">Enable Trails</button>
            </div>
            <div class="control-group">
                <label>Reset</label>
                <button id="nbody-reset">Reset System</button>
            </div>
        </div>
        <div class="demo-container" id="nbody-container"></div>
    </div>

    <!-- Demo 2: Fluid Flow Simulation -->
    <div class="demo-section">
        <h2>ðŸŒŠ Fluid Flow Simulation</h2>
        <div class="controls">
            <div class="control-group">
                <label>Viscosity</label>
                <input type="range" id="fluid-viscosity" min="0.1" max="2" step="0.1" value="0.8">
                <span class="value-display" id="viscosity-val">0.8</span>
            </div>
            <div class="control-group">
                <label>Flow Speed</label>
                <input type="range" id="fluid-speed" min="0.5" max="4" step="0.1" value="1.5">
                <span class="value-display" id="flow-speed-val">1.5</span>
            </div>
            <div class="control-group">
                <label>Turbulence</label>
                <input type="range" id="turbulence" min="0" max="100" step="5" value="30">
                <span class="value-display" id="turbulence-val">30</span>
            </div>
            <div class="control-group">
                <label>Color Mode</label>
                <button id="fluid-color-mode">Velocity</button>
            </div>
        </div>
        <div class="demo-container" id="fluid-container"></div>
    </div>

    <!-- Demo 3: Electromagnetic Field Visualization -->
    <div class="demo-section">
        <h2>âš¡ Electromagnetic Field Visualization</h2>
        <div class="controls">
            <div class="control-group">
                <label>Field Lines</label>
                <input type="range" id="field-density" min="5" max="25" step="1" value="15">
                <span class="value-display" id="field-density-val">15</span>
            </div>
            <div class="control-group">
                <label>Charge Strength</label>
                <input type="range" id="charge-strength" min="50" max="300" step="25" value="150">
                <span class="value-display" id="charge-val">150</span>
            </div>
            <div class="control-group">
                <label>Animation Speed</label>
                <input type="range" id="field-speed" min="0.2" max="3" step="0.2" value="1">
                <span class="value-display" id="field-speed-val">1</span>
            </div>
            <div class="control-group">
                <label>Field Type</label>
                <button id="field-type">Electric</button>
            </div>
        </div>
        <div class="demo-container" id="field-container"></div>
    </div>

    <!-- Demo 4: Fractal Growth System -->
    <div class="demo-section">
        <h2>ðŸŒ¿ Fractal Growth System</h2>
        <div class="controls">
            <div class="control-group">
                <label>Branches</label>
                <input type="range" id="fractal-branches" min="2" max="8" step="1" value="4">
                <span class="value-display" id="branches-val">4</span>
            </div>
            <div class="control-group">
                <label>Growth Rate</label>
                <input type="range" id="growth-rate" min="0.1" max="2" step="0.1" value="0.8">
                <span class="value-display" id="growth-val">0.8</span>
            </div>
            <div class="control-group">
                <label>Chaos Factor</label>
                <input type="range" id="chaos-factor" min="0" max="50" step="5" value="15">
                <span class="value-display" id="chaos-val">15</span>
            </div>
            <div class="control-group">
                <label>Pattern</label>
                <button id="fractal-pattern">Tree</button>
            </div>
            <div class="control-group">
                <label>Color</label>
                <input type="color" id="fractal-color" value="#4ecdc4">
            </div>
        </div>
        <div class="demo-container" id="fractal-container"></div>
    </div>

    <!-- Demo 5: Wave Interference Patterns -->
    <div class="demo-section">
        <h2>ðŸŒŠ Wave Interference Patterns</h2>
        <div class="controls">
            <div class="control-group">
                <label>Wave Sources</label>
                <input type="range" id="wave-sources" min="2" max="6" step="1" value="3">
                <span class="value-display" id="wave-sources-val">3</span>
            </div>
            <div class="control-group">
                <label>Frequency</label>
                <input type="range" id="wave-frequency" min="0.5" max="4" step="0.1" value="1.2">
                <span class="value-display" id="frequency-val">1.2</span>
            </div>
            <div class="control-group">
                <label>Amplitude</label>
                <input type="range" id="wave-amplitude" min="10" max="80" step="5" value="40">
                <span class="value-display" id="amplitude-val">40</span>
            </div>
            <div class="control-group">
                <label>Wave Type</label>
                <button id="wave-type">Sine</button>
            </div>
            <div class="control-group">
                <label>Visualization</label>
                <button id="wave-viz">Height Map</button>
            </div>
        </div>
        <div class="demo-container" id="wave-container"></div>
    </div>

    <!-- Demo 6: Quantum Visualization -->
    <div class="demo-section">
        <h2>ðŸ”¬ Quantum Wave Function</h2>
        <div class="controls">
            <div class="control-group">
                <label>Energy Level</label>
                <input type="range" id="quantum-energy" min="1" max="8" step="1" value="3">
                <span class="value-display" id="energy-val">3</span>
            </div>
            <div class="control-group">
                <label>Uncertainty</label>
                <input type="range" id="uncertainty" min="0.1" max="2" step="0.1" value="0.7">
                <span class="value-display" id="uncertainty-val">0.7</span>
            </div>
            <div class="control-group">
                <label>Observation Rate</label>
                <input type="range" id="observation-rate" min="0" max="100" step="10" value="30">
                <span class="value-display" id="observation-val">30</span>
            </div>
            <div class="control-group">
                <label>Orbital Type</label>
                <button id="orbital-type">S-Orbital</button>
            </div>
        </div>
        <div class="demo-container" id="quantum-container"></div>
    </div>

    <script>
        // Initialize Juris
        const juris = new Juris({
            renderMode: 'fine-grained',
            logLevel: 'error'
        });

        // Global animation state
        let animationFrame;
        let startTime = Date.now();
        let frameCount = 0;
        let lastFpsUpdate = Date.now();

        // Initialize all state
        juris.setState('time', 0);
        juris.setState('mouse.x', 0);
        juris.setState('mouse.y', 0);
        
        // N-Body System
        juris.setState('nbody.count', 6);
        juris.setState('nbody.gravity', 80);
        juris.setState('nbody.timeScale', 1);
        juris.setState('nbody.trails', false);
        juris.setState('nbody.reset', 0);

        // Fluid System
        juris.setState('fluid.viscosity', 0.8);
        juris.setState('fluid.speed', 1.5);
        juris.setState('fluid.turbulence', 30);
        juris.setState('fluid.colorMode', 'velocity');

        // Electromagnetic Field
        juris.setState('field.density', 15);
        juris.setState('field.strength', 150);
        juris.setState('field.speed', 1);
        juris.setState('field.type', 'electric');

        // Fractal System
        juris.setState('fractal.branches', 4);
        juris.setState('fractal.growthRate', 0.8);
        juris.setState('fractal.chaos', 15);
        juris.setState('fractal.pattern', 'tree');
        juris.setState('fractal.color', '#4ecdc4');

        // Wave System
        juris.setState('wave.sources', 3);
        juris.setState('wave.frequency', 1.2);
        juris.setState('wave.amplitude', 40);
        juris.setState('wave.type', 'sine');
        juris.setState('wave.visualization', 'heightmap');

        // Quantum System
        juris.setState('quantum.energy', 3);
        juris.setState('quantum.uncertainty', 0.7);
        juris.setState('quantum.observation', 30);
        juris.setState('quantum.orbital', 's');

        // Mouse tracking
        document.addEventListener('mousemove', (e) => {
            juris.setState('mouse.x', e.clientX);
            juris.setState('mouse.y', e.clientY);
        });

        // FPS counter
        function updateFPS() {
            frameCount++;
            const now = Date.now();
            if (now - lastFpsUpdate >= 1000) {
                const fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
                document.getElementById('fps-counter').textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        // Animation loop
        function animate() {
            const currentTime = (Date.now() - startTime) / 1000;
            juris.setState('time', currentTime);
            updateFPS();
            animationFrame = requestAnimationFrame(animate);
        }

        // Demo 1: N-Body Gravitational System
        const createNBody = (index) => {
            // Initialize orbital parameters
            const angle = (index * Math.PI * 2) / 6;
            const radius = 60 + index * 15;
            
            return {
                div: {
                    style: (element) => {
                        const time = juris.getState('time', 0);
                        const gravity = juris.getState('nbody.gravity', 80);
                        const timeScale = juris.getState('nbody.timeScale', 1);
                        const resetCounter = juris.getState('nbody.reset', 0);
                        const totalBodies = juris.getState('nbody.count', 6);

                        // Reset positions when reset counter changes
                        const resetTime = resetCounter * 1000; // Use reset as time offset
                        const adjustedTime = (time * timeScale) + resetTime;

                        // Complex orbital mechanics with perturbations
                        let x = 175 + Math.cos(adjustedTime * 0.3 + angle) * radius;
                        let y = 175 + Math.sin(adjustedTime * 0.3 + angle) * radius * 0.7;

                        // Add gravitational perturbations from other bodies
                        for (let i = 0; i < totalBodies; i++) {
                            if (i !== index) {
                                const otherAngle = (i * Math.PI * 2) / totalBodies;
                                const otherRadius = 60 + i * 15;
                                const otherX = 175 + Math.cos(adjustedTime * 0.3 + otherAngle) * otherRadius;
                                const otherY = 175 + Math.sin(adjustedTime * 0.3 + otherAngle) * otherRadius * 0.7;
                                
                                const dx = otherX - x;
                                const dy = otherY - y;
                                const distance = Math.sqrt(dx * dx + dy * dy) + 10; // Avoid singularity
                                const force = gravity / (distance * distance);
                                
                                x += (dx / distance) * force * 0.1;
                                y += (dy / distance) * force * 0.1;
                            }
                        }

                        const mass = 5 + index * 2;
                        const temperature = 3000 + index * 500;
                        const hue = (temperature / 50) % 360;

                        return {
                            position: 'absolute',
                            width: `${mass * 2}px`,
                            height: `${mass * 2}px`,
                            background: `radial-gradient(circle, hsl(${hue}, 80%, 70%), hsl(${hue}, 60%, 40%))`,
                            borderRadius: '50%',
                            left: `${x}px`,
                            top: `${y}px`,
                            transform: 'translate(-50%, -50%)',
                            boxShadow: `0 0 ${mass * 3}px hsl(${hue}, 80%, 60%), 
                                       0 0 ${mass * 6}px hsl(${hue}, 60%, 40%)`,
                            filter: `blur(${Math.sin(adjustedTime + index) * 0.5 + 0.5}px)`,
                            zIndex: Math.floor(mass)
                        };
                    }
                }
            };
        };

        // Demo 2: Fluid Flow Simulation
        const createFluidParticle = (index) => ({
            div: {
                style: () => {
                    const time = juris.getState('time', 0);
                    const viscosity = juris.getState('fluid.viscosity', 0.8);
                    const speed = juris.getState('fluid.speed', 1.5);
                    const turbulence = juris.getState('fluid.turbulence', 30);
                    const colorMode = juris.getState('fluid.colorMode', 'velocity');

                    // Fluid flow equations (simplified Navier-Stokes)
                    const flowTime = time * speed;
                    const x = (index % 20) * 17.5;
                    const y = Math.floor(index / 20) * 17.5;
                    
                    // Velocity field calculation
                    const vx = Math.sin(flowTime + x * 0.05) * (1 - viscosity);
                    const vy = Math.cos(flowTime + y * 0.05) * (1 - viscosity);
                    
                    // Add turbulence
                    const noise = Math.sin(flowTime * 3 + x * 0.1 + y * 0.1) * (turbulence / 100);
                    const finalX = x + vx * 20 + noise * 10;
                    const finalY = y + vy * 20 + noise * 10;
                    
                    // Color based on velocity or pressure
                    let hue, saturation, lightness;
                    if (colorMode === 'velocity') {
                        const velocity = Math.sqrt(vx * vx + vy * vy);
                        hue = 240 - velocity * 120; // Blue to red
                        saturation = 70 + velocity * 30;
                        lightness = 50 + velocity * 20;
                    } else {
                        const pressure = Math.sin(flowTime + x * 0.02 + y * 0.02);
                        hue = pressure * 60 + 180; // Cyan to blue
                        saturation = 80;
                        lightness = 40 + pressure * 30;
                    }

                    const opacity = 0.3 + Math.abs(noise) * 0.4;

                    return {
                        position: 'absolute',
                        width: '8px',
                        height: '8px',
                        background: `hsl(${hue}, ${saturation}%, ${lightness}%)`,
                        borderRadius: '50%',
                        left: `${finalX}px`,
                        top: `${finalY}px`,
                        transform: 'translate(-50%, -50%)',
                        opacity,
                        filter: `blur(${viscosity}px)`,
                        mixBlendMode: 'screen'
                    };
                }
            }
        });

        // Demo 3: Electromagnetic Field
        const createFieldLine = (index) => ({
            div: {
                style: () => {
                    const time = juris.getState('time', 0);
                    const density = juris.getState('field.density', 15);
                    const strength = juris.getState('field.strength', 150);
                    const fieldSpeed = juris.getState('field.speed', 1);
                    const fieldType = juris.getState('field.type', 'electric');

                    // Field line calculation
                    const angle = (index / density) * Math.PI * 2;
                    const radius = 50 + (index % 3) * 30;
                    
                    let x, y, rotation, intensity;
                    
                    if (fieldType === 'electric') {
                        // Radial electric field
                        x = 175 + Math.cos(angle) * radius;
                        y = 175 + Math.sin(angle) * radius;
                        rotation = (angle * 180 / Math.PI) + (time * fieldSpeed * 30);
                        intensity = strength / (radius * 0.1);
                    } else {
                        // Circular magnetic field
                        x = 175 + Math.cos(angle + time * fieldSpeed) * radius;
                        y = 175 + Math.sin(angle + time * fieldSpeed) * radius;
                        rotation = (angle * 180 / Math.PI) + 90 + (time * fieldSpeed * 60);
                        intensity = strength * 0.8;
                    }

                    const hue = fieldType === 'electric' ? 60 : 280; // Yellow for electric, purple for magnetic
                    const length = Math.min(intensity / 5, 40);

                    return {
                        position: 'absolute',
                        width: `${length}px`,
                        height: '2px',
                        background: `linear-gradient(90deg, 
                            transparent, 
                            hsl(${hue}, 80%, 60%), 
                            hsl(${hue}, 60%, 40%), 
                            transparent)`,
                        left: `${x}px`,
                        top: `${y}px`,
                        transform: `translate(-50%, -50%) rotate(${rotation}deg)`,
                        boxShadow: `0 0 5px hsl(${hue}, 80%, 60%)`,
                        opacity: 0.7
                    };
                }
            }
        });

        // Demo 4: Fractal Growth
        const createFractalBranch = (index, generation = 0) => ({
            div: {
                style: () => {
                    const time = juris.getState('time', 0);
                    const branches = juris.getState('fractal.branches', 4);
                    const growthRate = juris.getState('fractal.growthRate', 0.8);
                    const chaos = juris.getState('fractal.chaos', 15);
                    const pattern = juris.getState('fractal.pattern', 'tree');
                    const color = juris.getState('fractal.color', '#4ecdc4');

                    if (generation > 4) return { display: 'none' };

                    const angle = (index / branches) * Math.PI * 2;
                    const length = 40 * Math.pow(0.7, generation);
                    const growth = Math.min((time * growthRate - generation * 0.5), 1);
                    
                    if (growth <= 0) return { display: 'none' };

                    // Add chaos/randomness
                    const chaosAngle = Math.sin(time + index + generation) * (chaos / 100);
                    const finalAngle = angle + chaosAngle;
                    
                    let x, y;
                    if (pattern === 'tree') {
                        x = 175 + Math.cos(finalAngle - Math.PI / 2) * length * growth;
                        y = 175 + Math.sin(finalAngle - Math.PI / 2) * length * growth;
                    } else if (pattern === 'spiral') {
                        x = 175 + Math.cos(finalAngle + time * 0.5) * length * growth;
                        y = 175 + Math.sin(finalAngle + time * 0.5) * length * growth;
                    } else { // mandala
                        x = 175 + Math.cos(finalAngle) * length * growth;
                        y = 175 + Math.sin(finalAngle) * length * growth;
                    }

                    const thickness = Math.max(6 - generation * 1.5, 1);
                    const opacity = Math.max(0.9 - generation * 0.2, 0.2) * growth;

                    return {
                        position: 'absolute',
                        width: `${thickness}px`,
                        height: `${thickness}px`,
                        background: color,
                        borderRadius: '50%',
                        left: `${x}px`,
                        top: `${y}px`,
                        transform: 'translate(-50%, -50%)',
                        opacity,
                        boxShadow: `0 0 ${thickness * 2}px ${color}`,
                        filter: `hue-rotate(${generation * 30}deg)`
                    };
                }
            }
        });

        // Demo 5: Wave Interference
        const createWavePoint = (index) => ({
            div: {
                style: () => {
                    const time = juris.getState('time', 0);
                    const sources = juris.getState('wave.sources', 3);
                    const frequency = juris.getState('wave.frequency', 1.2);
                    const amplitude = juris.getState('wave.amplitude', 40);
                    const waveType = juris.getState('wave.type', 'sine');

                    const x = (index % 25) * 14;
                    const y = Math.floor(index / 25) * 14;
                    
                    let totalWave = 0;
                    
                    // Calculate interference from multiple sources
                    for (let s = 0; s < sources; s++) {
                        const sourceAngle = (s / sources) * Math.PI * 2;
                        const sourceX = 175 + Math.cos(sourceAngle) * 80;
                        const sourceY = 175 + Math.sin(sourceAngle) * 80;
                        
                        const distance = Math.sqrt((x - sourceX) ** 2 + (y - sourceY) ** 2);
                        const phase = time * frequency - distance * 0.1;
                        
                        if (waveType === 'sine') {
                            totalWave += Math.sin(phase);
                        } else if (waveType === 'square') {
                            totalWave += Math.sign(Math.sin(phase));
                        } else { // sawtooth
                            totalWave += (phase % (2 * Math.PI)) / Math.PI - 1;
                        }
                    }
                    
                    const normalizedWave = totalWave / sources;
                    const height = Math.abs(normalizedWave) * amplitude;
                    const hue = (normalizedWave + 1) * 180; // 0-360 degrees

                    return {
                        position: 'absolute',
                        width: '4px',
                        height: '4px',
                        background: `hsl(${hue}, 80%, ${50 + normalizedWave * 30}%)`,
                        borderRadius: '50%',
                        left: `${x}px`,
                        top: `${y - height * 0.5}px`,
                        transform: 'translate(-50%, -50%)',
                        boxShadow: `0 0 ${height * 0.2}px hsl(${hue}, 80%, 60%)`,
                        opacity: 0.7 + Math.abs(normalizedWave) * 0.3
                    };
                }
            }
        });

        // Demo 6: Quantum Visualization
        const createQuantumParticle = (index) => ({
            div: {
                style: () => {
                    const time = juris.getState('time', 0);
                    const energy = juris.getState('quantum.energy', 3);
                    const uncertainty = juris.getState('quantum.uncertainty', 0.7);
                    const observation = juris.getState('quantum.observation', 30);
                    const orbital = juris.getState('quantum.orbital', 's');

                    let x, y, probability;
                    
                    // Quantum orbital calculations
                    if (orbital === 's') {
                        // S-orbital (spherical)
                        const r = 50 + Math.random() * 40 * uncertainty;
                        const theta = Math.random() * Math.PI * 2;
                        x = 175 + Math.cos(theta) * r * Math.sin(time * 0.5 + index);
                        y = 175 + Math.sin(theta) * r * Math.sin(time * 0.5 + index);
                        probability = Math.exp(-r / (energy * 10));
                    } else if (orbital === 'p') {
                        // P-orbital (dumbbell)
                        const r = 40 + Math.random() * 30 * uncertainty;
                        const theta = index < 15 ? 0 : Math.PI;
                        x = 175 + Math.cos(theta + time * 0.3) * r;
                        y = 175 + Math.sin(theta + time * 0.3) * r * 0.3;
                        probability = Math.exp(-r / (energy * 8)) * Math.abs(Math.cos(theta));
                    } else { // d-orbital
                        // D-orbital (complex shape)
                        const r = 30 + Math.random() * 25 * uncertainty;
                        const theta = (index / 30) * Math.PI * 4;
                        x = 175 + Math.cos(theta + time * 0.4) * r * Math.sin(theta * 2);
                        y = 175 + Math.sin(theta + time * 0.4) * r * Math.sin(theta * 2);
                        probability = Math.exp(-r / (energy * 6)) * Math.abs(Math.sin(theta * 2));
                    }

                    // Heisenberg uncertainty principle
                    const observationEffect = observation / 100;
                    const blur = uncertainty * (1 - observationEffect) * 3;
                    const opacity = probability * (0.3 + observationEffect * 0.7);

                    return {
                        position: 'absolute',
                        width: '3px',
                        height: '3px',
                        background: `hsl(${280 + energy * 20}, 80%, 70%)`,
                        borderRadius: '50%',
                        left: `${x}px`,
                        top: `${y}px`,
                        transform: 'translate(-50%, -50%)',
                        opacity,
                        filter: `blur(${blur}px)`,
                        boxShadow: `0 0 ${5 + energy}px hsl(${280 + energy * 20}, 80%, 60%)`
                    };
                }
            }
        });

        // Render functions for each demo
        function renderNBodySystem() {
            const count = juris.getState('nbody.count', 6);
            const bodies = Array.from({ length: count }, (_, i) => createNBody(i));
            const element = juris.domRenderer.render({ div: { children: bodies } });
            document.getElementById('nbody-container').innerHTML = '';
            document.getElementById('nbody-container').appendChild(element);
        }

        function renderFluidSystem() {
            const particles = Array.from({ length: 350 }, (_, i) => createFluidParticle(i));
            const element = juris.domRenderer.render({ div: { children: particles } });
            document.getElementById('fluid-container').innerHTML = '';
            document.getElementById('fluid-container').appendChild(element);
        }

        function renderFieldSystem() {
            const density = juris.getState('field.density', 15);
            const lines = Array.from({ length: density }, (_, i) => createFieldLine(i));
            const element = juris.domRenderer.render({ div: { children: lines } });
            document.getElementById('field-container').innerHTML = '';
            document.getElementById('field-container').appendChild(element);
        }

        function renderFractalSystem() {
            const branches = juris.getState('fractal.branches', 4);
            const allBranches = [];
            
            // Generate multiple generations
            for (let gen = 0; gen < 5; gen++) {
                const branchCount = Math.pow(branches, gen + 1);
                for (let i = 0; i < branchCount; i++) {
                    allBranches.push(createFractalBranch(i, gen));
                }
            }
            
            const element = juris.domRenderer.render({ div: { children: allBranches } });
            document.getElementById('fractal-container').innerHTML = '';
            document.getElementById('fractal-container').appendChild(element);
        }

        function renderWaveSystem() {
            const points = Array.from({ length: 625 }, (_, i) => createWavePoint(i));
            const element = juris.domRenderer.render({ div: { children: points } });
            document.getElementById('wave-container').innerHTML = '';
            document.getElementById('wave-container').appendChild(element);
        }

        function renderQuantumSystem() {
            const particles = Array.from({ length: 100 }, (_, i) => createQuantumParticle(i));
            const element = juris.domRenderer.render({ div: { children: particles } });
            document.getElementById('quantum-container').innerHTML = '';
            document.getElementById('quantum-container').appendChild(element);
        }

        // Event listeners setup
        function setupEventListeners() {
            // N-Body controls
            ['nbody-count', 'gravity-strength', 'time-scale'].forEach(id => {
                const element = document.getElementById(id);
                const stateKey = id.replace('nbody-', 'nbody.').replace('gravity-strength', 'nbody.gravity').replace('time-scale', 'nbody.timeScale');
                const valueDisplay = document.getElementById(id + '-val') || document.getElementById(id.split('-')[1] + '-val');
                
                element.addEventListener('input', (e) => {
                    const value = id.includes('count') ? parseInt(e.target.value) : parseFloat(e.target.value);
                    juris.setState(stateKey, value);
                    if (valueDisplay) valueDisplay.textContent = value;
                    if (id === 'nbody-count') renderNBodySystem();
                });
            });

            document.getElementById('trails-toggle').addEventListener('click', (e) => {
                const trails = juris.getState('nbody.trails', false);
                juris.setState('nbody.trails', !trails);
                e.target.textContent = trails ? 'Enable Trails' : 'Disable Trails';
                e.target.classList.toggle('active', !trails);
            });

            document.getElementById('nbody-reset').addEventListener('click', () => {
                juris.setState('nbody.reset', juris.getState('nbody.reset', 0) + 1);
            });

            // Fluid controls
            ['fluid-viscosity', 'fluid-speed', 'turbulence'].forEach(id => {
                const element = document.getElementById(id);
                const stateKey = id.replace('fluid-', 'fluid.').replace('turbulence', 'fluid.turbulence');
                const valueDisplay = document.getElementById(id.replace('fluid-', '').replace('turbulence', 'turbulence') + '-val');
                
                element.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    juris.setState(stateKey, value);
                    if (valueDisplay) valueDisplay.textContent = value;
                });
            });

            document.getElementById('fluid-color-mode').addEventListener('click', (e) => {
                const mode = juris.getState('fluid.colorMode', 'velocity');
                const newMode = mode === 'velocity' ? 'pressure' : 'velocity';
                juris.setState('fluid.colorMode', newMode);
                e.target.textContent = newMode === 'velocity' ? 'Pressure' : 'Velocity';
                e.target.classList.toggle('active', newMode === 'pressure');
            });

            // Field controls
            ['field-density', 'charge-strength', 'field-speed'].forEach(id => {
                const element = document.getElementById(id);
                const stateKey = id.replace('field-', 'field.').replace('charge-strength', 'field.strength');
                const valueDisplay = document.getElementById(id.replace('field-', '').replace('charge-strength', 'charge') + '-val');
                
                element.addEventListener('input', (e) => {
                    const value = id.includes('density') ? parseInt(e.target.value) : parseFloat(e.target.value);
                    juris.setState(stateKey, value);
                    if (valueDisplay) valueDisplay.textContent = value;
                    if (id === 'field-density') renderFieldSystem();
                });
            });

            document.getElementById('field-type').addEventListener('click', (e) => {
                const type = juris.getState('field.type', 'electric');
                const newType = type === 'electric' ? 'magnetic' : 'electric';
                juris.setState('field.type', newType);
                e.target.textContent = newType === 'electric' ? 'Magnetic' : 'Electric';
                e.target.classList.toggle('active', newType === 'magnetic');
            });

            // Continue with remaining controls...
            // Fractal controls
            ['fractal-branches', 'growth-rate', 'chaos-factor'].forEach(id => {
                const element = document.getElementById(id);
                const stateKey = id.replace('fractal-', 'fractal.').replace('growth-rate', 'fractal.growthRate').replace('chaos-factor', 'fractal.chaos');
                const valueDisplay = document.getElementById(id.replace('fractal-', '').replace('growth-rate', 'growth').replace('chaos-factor', 'chaos') + '-val');
                
                element.addEventListener('input', (e) => {
                    const value = id.includes('branches') || id.includes('chaos') ? parseInt(e.target.value) : parseFloat(e.target.value);
                    juris.setState(stateKey, value);
                    if (valueDisplay) valueDisplay.textContent = value;
                    if (id === 'fractal-branches') renderFractalSystem();
                });
            });

            document.getElementById('fractal-pattern').addEventListener('click', (e) => {
                const patterns = ['tree', 'spiral', 'mandala'];
                const current = juris.getState('fractal.pattern', 'tree');
                const nextIndex = (patterns.indexOf(current) + 1) % patterns.length;
                const newPattern = patterns[nextIndex];
                juris.setState('fractal.pattern', newPattern);
                e.target.textContent = newPattern.charAt(0).toUpperCase() + newPattern.slice(1);
            });

            document.getElementById('fractal-color').addEventListener('input', (e) => {
                juris.setState('fractal.color', e.target.value);
            });

            // Wave controls
            ['wave-sources', 'wave-frequency', 'wave-amplitude'].forEach(id => {
                const element = document.getElementById(id);
                const stateKey = id.replace('wave-', 'wave.');
                const valueDisplay = document.getElementById(id.replace('wave-', '') + '-val');
                
                element.addEventListener('input', (e) => {
                    const value = id.includes('sources') || id.includes('amplitude') ? parseInt(e.target.value) : parseFloat(e.target.value);
                    juris.setState(stateKey, value);
                    if (valueDisplay) valueDisplay.textContent = value;
                });
            });

            document.getElementById('wave-type').addEventListener('click', (e) => {
                const types = ['sine', 'square', 'sawtooth'];
                const current = juris.getState('wave.type', 'sine');
                const nextIndex = (types.indexOf(current) + 1) % types.length;
                const newType = types[nextIndex];
                juris.setState('wave.type', newType);
                e.target.textContent = newType.charAt(0).toUpperCase() + newType.slice(1);
            });

            document.getElementById('wave-viz').addEventListener('click', (e) => {
                const viz = juris.getState('wave.visualization', 'heightmap');
                const newViz = viz === 'heightmap' ? 'contour' : 'heightmap';
                juris.setState('wave.visualization', newViz);
                e.target.textContent = newViz === 'heightmap' ? 'Contour' : 'Height Map';
                e.target.classList.toggle('active', newViz === 'contour');
            });

            // Quantum controls
            ['quantum-energy', 'uncertainty', 'observation-rate'].forEach(id => {
                const element = document.getElementById(id);
                const stateKey = id.replace('quantum-', 'quantum.').replace('observation-rate', 'quantum.observation');
                const valueDisplay = document.getElementById(id.replace('quantum-', '').replace('observation-rate', 'observation') + '-val');
                
                element.addEventListener('input', (e) => {
                    const value = id.includes('energy') || id.includes('observation') ? parseInt(e.target.value) : parseFloat(e.target.value);
                    juris.setState(stateKey, value);
                    if (valueDisplay) valueDisplay.textContent = value;
                });
            });

            document.getElementById('orbital-type').addEventListener('click', (e) => {
                const orbitals = ['s', 'p', 'd'];
                const current = juris.getState('quantum.orbital', 's');
                const nextIndex = (orbitals.indexOf(current) + 1) % orbitals.length;
                const newOrbital = orbitals[nextIndex];
                juris.setState('quantum.orbital', newOrbital);
                e.target.textContent = `${newOrbital.toUpperCase()}-Orbital`;
            });
        }

        // Initialize everything
        renderNBodySystem();
        renderFluidSystem();
        renderFieldSystem();
        renderFractalSystem();
        renderWaveSystem();
        renderQuantumSystem();

        setupEventListeners();

        // Start animation
        animate();

        console.log('ðŸš€ Advanced Juris Computational Style Showcase loaded!');
        console.log('All animations are powered by reactive DOM styles with real-time calculations.');
    </script>
</body>
</html>