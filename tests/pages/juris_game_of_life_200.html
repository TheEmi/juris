// Handle attributes
                if (elementDef.id) {
                    element.id = elementDef.id;
                }<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juris Game of Life - 200 Cells Performance Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
            overflow-x: auto;
        }

        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .performance-notice {
            background: rgba(34, 197, 94, 0.2);
            border: 1px solid rgba(34, 197, 94, 0.4);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .performance-notice h3 {
            color: #22c55e;
            margin-bottom: 8px;
        }

        .controls {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-size: 0.9rem;
            font-weight: 600;
            opacity: 0.9;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .primary-btn {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
        }

        .primary-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.4);
        }

        .secondary-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .secondary-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .danger-btn {
            background: linear-gradient(135deg, #ff416c, #ff4b2b);
            color: white;
        }

        .danger-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 65, 108, 0.4);
        }

        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .game-area {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .grid-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            overflow: auto;
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .grid {
            display: inline-grid;
            gap: 1px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            grid-template-columns: repeat(30, 16px);
            grid-template-rows: repeat(20, 16px);
        }

        .cell {
            width: 16px;
            height: 16px;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.1s ease;
            border-radius: 2px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .cell.alive {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
            border-color: #ffd700;
        }

        .cell.just-born {
            animation: birth 0.3s ease;
        }

        .cell.just-died {
            animation: death 0.3s ease;
        }

        @keyframes birth {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes death {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(0.8); opacity: 0.5; }
            100% { transform: scale(1); opacity: 0.1; }
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .stats-panel, .performance-panel, .patterns-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
        }

        .stats-panel h3, .performance-panel h3, .patterns-panel h3 {
            margin-bottom: 15px;
            font-size: 1.2rem;
            color: #ffd700;
        }

        .stat-item, .perf-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-label, .perf-label {
            opacity: 0.8;
            font-size: 0.9rem;
        }

        .stat-value, .perf-value {
            font-weight: 600;
            color: #ffd700;
        }

        .pattern-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid #ffd700;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .pattern-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .pattern-name {
            font-weight: 600;
            color: #ffd700;
            margin-bottom: 5px;
        }

        .pattern-description {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .generation-counter {
            font-size: 1.5rem;
            font-weight: 600;
            color: #ffd700;
            text-align: center;
            margin: 10px 0;
        }

        @media (max-width: 768px) {
            .game-area {
                grid-template-columns: 1fr;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .grid {
                grid-template-columns: repeat(30, 12px);
                grid-template-rows: repeat(20, 12px);
            }
            
            .cell {
                width: 12px;
                height: 12px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div id="app"></div>

    <!-- Mock Juris Framework for testing -->
    <script>
        // Simple Juris Framework Mock for Performance Testing
        class Juris {
            constructor(config) {
                this.components = config.components || {};
                this.layout = config.layout;
                this.state = {};
                this.componentInstances = new Map();
                this.updateQueue = new Set();
                this.isUpdating = false;
            }

            render(selector) {
                this.container = document.querySelector(selector);
                this.renderComponent(this.layout, this.container);
                this.flushUpdates();
            }

            renderComponent(componentDef, parent, props = {}) {
                if (typeof componentDef === 'string') {
                    const textNode = document.createTextNode(componentDef);
                    parent.appendChild(textNode);
                    return textNode;
                }

                if (componentDef.text) {
                    const textNode = document.createTextNode(
                        typeof componentDef.text === 'function' ? componentDef.text() : componentDef.text
                    );
                    parent.appendChild(textNode);
                    return textNode;
                }

                // Handle component references
                const componentName = Object.keys(componentDef)[0];
                if (this.components[componentName]) {
                    const componentProps = componentDef[componentName];
                    const componentInstance = this.components[componentName](componentProps, this);
                    
                    if (componentInstance.render) {
                        const element = this.renderComponent(componentInstance.render(), parent, componentProps);
                        
                        // Store component instance
                        if (componentProps.key) {
                            this.componentInstances.set(componentProps.key, componentInstance);
                        }
                        
                        // Call onMount if it exists
                        if (componentInstance.onMount) {
                            componentInstance.onMount(element, componentProps, this);
                        }
                        
                        return element;
                    }
                }

                // Handle regular DOM elements
                const tagName = Object.keys(componentDef)[0];
                const elementDef = componentDef[tagName];
                const element = document.createElement(tagName);

                if (elementDef.className) {
                    const className = typeof elementDef.className === 'function' ? elementDef.className() : elementDef.className;
                    element.className = className;
                }

                if (elementDef.style) {
                    const style = typeof elementDef.style === 'function' ? elementDef.style() : elementDef.style;
                    Object.assign(element.style, style);
                }

                // Handle attributes
                if (elementDef.id) {
                    element.id = elementDef.id;
                }

                if (elementDef.value) {
                    const value = typeof elementDef.value === 'function' ? elementDef.value() : elementDef.value;
                    element.value = value;
                }

                // Handle event listeners
                Object.keys(elementDef).forEach(key => {
                    if (key.startsWith('on') && typeof elementDef[key] === 'function') {
                        const eventName = key.slice(2).toLowerCase();
                        element.addEventListener(eventName, elementDef[key]);
                    }
                });

                // Handle data attributes
                Object.keys(elementDef).forEach(key => {
                    if (key.startsWith('data-')) {
                        element.setAttribute(key, elementDef[key]);
                    }
                });

                // Handle text content
                if (elementDef.text) {
                    const text = typeof elementDef.text === 'function' ? elementDef.text() : elementDef.text;
                    element.textContent = text;
                }

                if (elementDef.children) {
                    const children = typeof elementDef.children === 'function' ? elementDef.children() : elementDef.children;
                    if (Array.isArray(children)) {
                        children.forEach(child => this.renderComponent(child, element));
                    } else if (children) {
                        this.renderComponent(children, element);
                    }
                }

                parent.appendChild(element);
                return element;
            }

            setState(path, value) {
                const keys = path.split('.');
                let current = this.state;
                
                for (let i = 0; i < keys.length - 1; i++) {
                    if (!current[keys[i]]) {
                        current[keys[i]] = {};
                    }
                    current = current[keys[i]];
                }
                
                current[keys[keys.length - 1]] = value;
                this.scheduleUpdate();
            }

            getState(path, defaultValue = null) {
                const keys = path.split('.');
                let current = this.state;
                
                for (let key of keys) {
                    if (current === null || current === undefined || !current.hasOwnProperty(key)) {
                        return defaultValue;
                    }
                    current = current[key];
                }
                
                return current;
            }

            scheduleUpdate() {
                if (!this.isUpdating) {
                    requestAnimationFrame(() => this.flushUpdates());
                }
            }

            flushUpdates() {
                this.isUpdating = true;
                
                // Instead of re-rendering everything, update only changed elements
                this.updateChangedElements();
                
                this.isUpdating = false;
            }

            updateChangedElements() {
                // Update only elements that use dynamic content
                const cells = document.querySelectorAll('.cell');
                cells.forEach(cell => {
                    const x = parseInt(cell.dataset.x);
                    const y = parseInt(cell.dataset.y);
                    const isAlive = this.getState(`grid.${x}.${y}`, false);
                    const justBorn = this.getState(`animations.${x}.${y}.justBorn`, false);
                    const justDied = this.getState(`animations.${x}.${y}.justDied`, false);
                    
                    // Update CSS classes (affects background)
                    let classes = 'cell';
                    if (isAlive) classes += ' alive';
                    if (justBorn) classes += ' just-born';
                    if (justDied) classes += ' just-died';
                    cell.className = classes;

                    // Direct style updates (alternative to CSS classes)
                    if (isAlive) {
                        cell.style.background = 'linear-gradient(135deg, #ffd700, #ffed4e)';
                        cell.style.boxShadow = '0 0 8px rgba(255, 215, 0, 0.6)';
                        cell.style.borderColor = '#ffd700';
                    } else {
                        cell.style.background = 'rgba(255, 255, 255, 0.1)';
                        cell.style.boxShadow = 'none';
                        cell.style.borderColor = 'rgba(255, 255, 255, 0.1)';
                    }
                });

                // Update statistics text content
                this.updateTextContent('generation', this.getState('game.generation', 0));
                this.updateTextContent('aliveCells', this.getState('game.aliveCells', 0));
                this.updateTextContent('density', `${((this.getState('game.aliveCells', 0) / 600) * 100).toFixed(1)}%`);
                this.updateTextContent('speed', `${this.getState('game.speed', 300)}ms`);
                this.updateTextContent('status', this.getState('game.running', false) ? 'Running' : 'Stopped');

                // Update performance metrics
                this.updateTextContent('frameTime', `${this.getState('performance.frameTime', '0')}ms`);
                this.updateTextContent('averageFrameTime', `${this.getState('performance.averageFrameTime', '0')}ms`);
                this.updateTextContent('peakFrameTime', `${this.getState('performance.peakFrameTime', '0')}ms`);
                this.updateTextContent('updateCount', this.getState('performance.updateCount', 0));
                this.updateTextContent('memoryUsage', `${this.getState('performance.memoryUsage', '0')}MB`);

                // Update play button style and text
                const playBtn = document.querySelector('#playBtn');
                if (playBtn) {
                    const running = this.getState('game.running', false);
                    playBtn.textContent = running ? '⏸️ Pause' : '▶️ Play';
                    playBtn.className = running ? 'danger-btn' : 'primary-btn';
                }

                // Update speed slider
                const speedSlider = document.querySelector('#speedSlider');
                if (speedSlider) {
                    speedSlider.value = this.getState('game.speed', 300);
                }

                // Update generation counter with dynamic styling
                const genCounter = document.querySelector('.generation-counter');
                if (genCounter) {
                    const generation = this.getState('game.generation', 0);
                    genCounter.textContent = `Generation: ${generation}`;
                    
                    // Dynamic styling based on generation count
                    if (generation > 100) {
                        genCounter.style.color = '#ff6b6b'; // Red for high generations
                    } else if (generation > 50) {
                        genCounter.style.color = '#ffa726'; // Orange for medium generations
                    } else {
                        genCounter.style.color = '#ffd700'; // Gold for low generations
                    }
                }
            }

            updateTextContent(id, value) {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = value;
                }
            }

            getComponent(name) {
                return this.componentInstances.get(name);
            }
        }

        // Global Juris reference
        window.Juris = Juris;
    </script>

    <script>
        // Game of Life Implementation using Juris Framework
        // PERFORMANCE TEST VERSION - 200 cells (20x10)
        
        // Performance tracking
        let performanceMetrics = {
            frameTime: 0,
            updateCount: 0,
            averageFrameTime: 0,
            peakFrameTime: 0,
            memoryUsage: 0
        };

        // Cell Component - Each cell is an intelligent entity
        const Cell = (props, context) => {
            const component = {
                render() {
                    return {
                        div: {
                            className: () => {
                                const isAlive = context.getState(`grid.${props.x}.${props.y}`, false);
                                const justBorn = context.getState(`animations.${props.x}.${props.y}.justBorn`, false);
                                const justDied = context.getState(`animations.${props.x}.${props.y}.justDied`, false);
                                
                                let classes = 'cell';
                                if (isAlive) classes += ' alive';
                                if (justBorn) classes += ' just-born';
                                if (justDied) classes += ' just-died';
                                
                                return classes;
                            },
                            onClick: () => component.toggle(),
                            'data-x': props.x,
                            'data-y': props.y
                        }
                    };
                },

                onMount(element, props, context) {
                    // Initialize cell state
                    if (context.getState(`grid.${props.x}.${props.y}`) === null) {
                        context.setState(`grid.${props.x}.${props.y}`, false);
                    }
                },

                // Cell API
                toggle() {
                    const current = context.getState(`grid.${props.x}.${props.y}`, false);
                    context.setState(`grid.${props.x}.${props.y}`, !current);
                    
                    // Update statistics
                    const engine = window.gameOfLife?.getComponent('GameEngine');
                    if (engine) {
                        engine.updateStatistics();
                    }
                },

                isAlive() {
                    return context.getState(`grid.${props.x}.${props.y}`, false);
                },

                setAlive(alive) {
                    const wasAlive = context.getState(`grid.${props.x}.${props.y}`, false);
                    context.setState(`grid.${props.x}.${props.y}`, alive);
                    
                    // Set animation flags
                    if (!wasAlive && alive) {
                        context.setState(`animations.${props.x}.${props.y}.justBorn`, true);
                        setTimeout(() => context.setState(`animations.${props.x}.${props.y}.justBorn`, false), 300);
                    } else if (wasAlive && !alive) {
                        context.setState(`animations.${props.x}.${props.y}.justDied`, true);
                        setTimeout(() => context.setState(`animations.${props.x}.${props.y}.justDied`, false), 300);
                    }
                }
            };
            
            return component;
        };

        // Grid Component - 20x10 grid (200 cells)
        const Grid = (props, context) => {
            return {
                render() {
                    return {
                        div: {
                            className: 'grid',
                            children: () => {
                                const cells = [];
                                
                                // 30x20 grid = 600 cells
                                for (let y = 0; y < 20; y++) {
                                    for (let x = 0; x < 30; x++) {
                                        cells.push({
                                            Cell: { x, y, key: `cell-${x}-${y}` }
                                        });
                                    }
                                }
                                
                                return cells;
                            }
                        }
                    };
                },

                onMount(element, props, context) {
                    console.log('🎯 Grid mounted - 600 cells (30x20)');
                    context.setState('game.width', 30);
                    context.setState('game.height', 20);
                    context.setState('game.totalCells', 600);
                }
            };
        };

        // Game Engine Component - Fixed accuracy with performance tracking
        const GameEngine = (props, context) => {
            let gameLoop = null;
            
            const component = {
                render() {
                    return {
                        div: { 
                            style: { display: 'none' },
                            key: 'GameEngine'
                        }
                    };
                },

                onMount(element, props, context) {
                    console.log('🎮 GameEngine mounted');
                    
                    // Initialize game state
                    context.setState('game.generation', 0);
                    context.setState('game.running', false);
                    context.setState('game.speed', 300);
                    context.setState('game.aliveCells', 0);
                    
                    return () => {
                        if (gameLoop) {
                            clearInterval(gameLoop);
                        }
                    };
                },

                // Game Engine API
                start() {
                    if (gameLoop) return;
                    
                    context.setState('game.running', true);
                    const speed = context.getState('game.speed', 300);
                    
                    gameLoop = setInterval(() => {
                        component.nextGeneration();
                    }, speed);
                    
                    console.log('🎮 Game started');
                },

                stop() {
                    if (gameLoop) {
                        clearInterval(gameLoop);
                        gameLoop = null;
                    }
                    context.setState('game.running', false);
                    console.log('⏹️ Game stopped');
                },

                step() {
                    component.nextGeneration();
                },

                reset() {
                    component.stop();
                    context.setState('game.generation', 0);
                    
                    // Clear all cells
                    for (let x = 0; x < 30; x++) {
                        for (let y = 0; y < 20; y++) {
                            context.setState(`grid.${x}.${y}`, false);
                        }
                    }
                    
                    component.updateStatistics();
                    console.log('🔄 Game reset');
                },

                setSpeed(speed) {
                    context.setState('game.speed', speed);
                    
                    if (gameLoop) {
                        component.stop();
                        component.start();
                    }
                },

                nextGeneration() {
                    const startTime = performance.now();
                    const generation = context.getState('game.generation', 0);
                    
                    // FIXED: Two-phase update for accuracy
                    // Phase 1: Calculate all next states without applying changes
                    const nextStates = {};
                    
                    for (let x = 0; x < 30; x++) {
                        for (let y = 0; y < 20; y++) {
                            const neighbors = component.countNeighbors(x, y);
                            const isAlive = context.getState(`grid.${x}.${y}`, false);
                            
                            // Conway's rules
                            let nextState = isAlive;
                            if (isAlive && (neighbors < 2 || neighbors > 3)) {
                                nextState = false;
                            } else if (!isAlive && neighbors === 3) {
                                nextState = true;
                            }
                            
                            nextStates[`${x}-${y}`] = { nextState, wasAlive: isAlive };
                        }
                    }
                    
                    // Phase 2: Apply all changes simultaneously
                    Object.keys(nextStates).forEach(key => {
                        const [x, y] = key.split('-').map(Number);
                        const { nextState, wasAlive } = nextStates[key];
                        
                        context.setState(`grid.${x}.${y}`, nextState);
                        
                        // Set animation flags
                        if (!wasAlive && nextState) {
                            context.setState(`animations.${x}.${y}.justBorn`, true);
                            setTimeout(() => context.setState(`animations.${x}.${y}.justBorn`, false), 300);
                        } else if (wasAlive && !nextState) {
                            context.setState(`animations.${x}.${y}.justDied`, true);
                            setTimeout(() => context.setState(`animations.${x}.${y}.justDied`, false), 300);
                        }
                    });
                    
                    context.setState('game.generation', generation + 1);
                    component.updateStatistics();
                    
                    // Performance tracking
                    const endTime = performance.now();
                    const frameTime = endTime - startTime;
                    
                    performanceMetrics.frameTime = frameTime;
                    performanceMetrics.updateCount++;
                    performanceMetrics.averageFrameTime = 
                        (performanceMetrics.averageFrameTime * (performanceMetrics.updateCount - 1) + frameTime) / performanceMetrics.updateCount;
                    performanceMetrics.peakFrameTime = Math.max(performanceMetrics.peakFrameTime, frameTime);
                    
                    if (performance.memory) {
                        performanceMetrics.memoryUsage = performance.memory.usedJSHeapSize / 1024 / 1024;
                    }
                    
                    component.updatePerformanceDisplay();
                },

                countNeighbors(x, y) {
                    let count = 0;
                    
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            // Check bounds (no wrapping)
                            if (nx >= 0 && nx < 30 && ny >= 0 && ny < 20) {
                                if (context.getState(`grid.${nx}.${ny}`, false)) {
                                    count++;
                                }
                            }
                        }
                    }
                    return count;
                },

                updateStatistics() {
                    let aliveCount = 0;
                    
                    for (let x = 0; x < 30; x++) {
                        for (let y = 0; y < 20; y++) {
                            if (context.getState(`grid.${x}.${y}`, false)) {
                                aliveCount++;
                            }
                        }
                    }
                    
                    context.setState('game.aliveCells', aliveCount);
                },

                updatePerformanceDisplay() {
                    context.setState('performance.frameTime', performanceMetrics.frameTime.toFixed(2));
                    context.setState('performance.averageFrameTime', performanceMetrics.averageFrameTime.toFixed(2));
                    context.setState('performance.peakFrameTime', performanceMetrics.peakFrameTime.toFixed(2));
                    context.setState('performance.updateCount', performanceMetrics.updateCount);
                    context.setState('performance.memoryUsage', performanceMetrics.memoryUsage.toFixed(1));
                },

                randomize(density = 0.3) {
                    for (let x = 0; x < 30; x++) {
                        for (let y = 0; y < 20; y++) {
                            const alive = Math.random() < density;
                            context.setState(`grid.${x}.${y}`, alive);
                        }
                    }
                    
                    component.updateStatistics();
                    console.log(`🎲 Grid randomized with ${density * 100}% density`);
                },

                placePattern(pattern, startX, startY) {
                    component.reset();
                    
                    for (let y = 0; y < pattern.length; y++) {
                        for (let x = 0; x < pattern[y].length; x++) {
                            const px = startX + x;
                            const py = startY + y;
                            
                            if (px >= 0 && px < 30 && py >= 0 && py < 20) {
                                context.setState(`grid.${px}.${py}`, pattern[y][x] === 1);
                            }
                        }
                    }
                    
                    component.updateStatistics();
                }
            };
            
            return component;
        };

        // Statistics Component - Now with static IDs for efficient updates
        const Statistics = (props, context) => {
            return {
                render() {
                    return {
                        div: {
                            className: 'stats-panel',
                            children: [
                                { h3: { text: '📊 Game Statistics' } },
                                {
                                    div: {
                                        className: 'stat-item',
                                        children: [
                                            { span: { className: 'stat-label', text: 'Generation:' } },
                                            { span: { className: 'stat-value', text: '0', id: 'generation' } }
                                        ]
                                    }
                                },
                                {
                                    div: {
                                        className: 'stat-item',
                                        children: [
                                            { span: { className: 'stat-label', text: 'Alive Cells:' } },
                                            { span: { className: 'stat-value', text: '0', id: 'aliveCells' } }
                                        ]
                                    }
                                },
                                {
                                    div: {
                                        className: 'stat-item',
                                        children: [
                                            { span: { className: 'stat-label', text: 'Total Cells:' } },
                                            { span: { className: 'stat-value', text: '200' } }
                                        ]
                                    }
                                },
                                {
                                    div: {
                                        className: 'stat-item',
                                        children: [
                                            { span: { className: 'stat-label', text: 'Density:' } },
                                            { span: { className: 'stat-value', text: '0%', id: 'density' } }
                                        ]
                                    }
                                },
                                {
                                    div: {
                                        className: 'stat-item',
                                        children: [
                                            { span: { className: 'stat-label', text: 'Speed:' } },
                                            { span: { className: 'stat-value', text: '300ms', id: 'speed' } }
                                        ]
                                    }
                                },
                                {
                                    div: {
                                        className: 'stat-item',
                                        children: [
                                            { span: { className: 'stat-label', text: 'Status:' } },
                                            { span: { className: 'stat-value', text: 'Stopped', id: 'status' } }
                                        ]
                                    }
                                }
                            ]
                        }
                    };
                }
            };
        };

        // Performance Metrics Component - Now with static IDs
        const PerformancePanel = (props, context) => {
            return {
                render() {
                    return {
                        div: {
                            className: 'performance-panel',
                            children: [
                                { h3: { text: '⚡ Performance Metrics' } },
                                {
                                    div: {
                                        className: 'perf-item',
                                        children: [
                                            { span: { className: 'perf-label', text: 'Frame Time:' } },
                                            { span: { className: 'perf-value', text: '0ms', id: 'frameTime' } }
                                        ]
                                    }
                                },
                                {
                                    div: {
                                        className: 'perf-item',
                                        children: [
                                            { span: { className: 'perf-label', text: 'Avg Frame:' } },
                                            { span: { className: 'perf-value', text: '0ms', id: 'averageFrameTime' } }
                                        ]
                                    }
                                },
                                {
                                    div: {
                                        className: 'perf-item',
                                        children: [
                                            { span: { className: 'perf-label', text: 'Peak Frame:' } },
                                            { span: { className: 'perf-value', text: '0ms', id: 'peakFrameTime' } }
                                        ]
                                    }
                                },
                                {
                                    div: {
                                        className: 'perf-item',
                                        children: [
                                            { span: { className: 'perf-label', text: 'Updates:' } },
                                            { span: { className: 'perf-value', text: '0', id: 'updateCount' } }
                                        ]
                                    }
                                },
                                {
                                    div: {
                                        className: 'perf-item',
                                        children: [
                                            { span: { className: 'perf-label', text: 'Memory:' } },
                                            { span: { className: 'perf-value', text: '0MB', id: 'memoryUsage' } }
                                        ]
                                    }
                                }
                            ]
                        }
                    };
                }
            };
        };

        // Game Controls Component
        const GameControls = (props, context) => {
            return {
                render() {
                    return {
                        div: {
                            className: 'controls',
                            children: [
                                // Play/Pause controls
                                {
                                    div: {
                                        className: 'control-group',
                                        children: [
                                            { label: { text: 'Game Control' } },
                                            {
                                                div: {
                                                    className: 'button-group',
                                                    children: () => {
                                                        const running = context.getState('game.running', false);
                                                        return [
                                                            {
                                                                button: {
                                                                    className: 'primary-btn',
                                                                    text: '▶️ Play',
                                                                    id: 'playBtn',
                                                                    onClick: () => {
                                                                        const engine = window.gameOfLife?.getComponent('GameEngine');
                                                                        if (engine) {
                                                                            const running = context.getState('game.running', false);
                                                                            if (running) {
                                                                                engine.stop();
                                                                            } else {
                                                                                engine.start();
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            },
                                                            {
                                                                button: {
                                                                    className: 'secondary-btn',
                                                                    text: '⏭️ Step',
                                                                    onClick: () => {
                                                                        const engine = window.gameOfLife?.getComponent('GameEngine');
                                                                        if (engine) engine.step();
                                                                    }
                                                                }
                                                            },
                                                            {
                                                                button: {
                                                                    className: 'secondary-btn',
                                                                    text: '🔄 Reset',
                                                                    onClick: () => {
                                                                        const engine = window.gameOfLife?.getComponent('GameEngine');
                                                                        if (engine) engine.reset();
                                                                    }
                                                                }
                                                            }
                                                        ];
                                                    }
                                                }
                                            }
                                        ]
                                    }
                                },
                                
                                // Speed control
                                {
                                    div: {
                                        className: 'control-group',
                                        children: [
                                            { label: { text: 'Speed: 300ms', id: 'speedLabel' } },
                                            {
                                                input: {
                                                    type: 'range',
                                                    min: 50,
                                                    max: 1000,
                                                    step: 50,
                                                    value: 300,
                                                    id: 'speedSlider',
                                                    onInput: (e) => {
                                                        const speed = parseInt(e.target.value);
                                                        context.setState('game.speed', speed);
                                                        document.getElementById('speedLabel').textContent = `Speed: ${speed}ms`;
                                                        const engine = window.gameOfLife?.getComponent('GameEngine');
                                                        if (engine) engine.setSpeed(speed);
                                                    }
                                                }
                                            }
                                        ]
                                    }
                                },
                                
                                // Random generation
                                {
                                    div: {
                                        className: 'control-group',
                                        children: [
                                            { label: { text: 'Random Generation' } },
                                            {
                                                div: {
                                                    className: 'button-group',
                                                    children: [
                                                        {
                                                            button: {
                                                                className: 'secondary-btn',
                                                                text: '🎲 Random',
                                                                onClick: () => {
                                                                    const engine = window.gameOfLife?.getComponent('GameEngine');
                                                                    if (engine) engine.randomize(0.3);
                                                                }
                                                            }
                                                        }
                                                    ]
                                                }
                                            }
                                        ]
                                    }
                                }
                            ]
                        }
                    };
                }
            };
        };

        // Patterns Component
        const PatternsPanel = (props, context) => {
            const patterns = {
                glider: {
                    name: 'Glider',
                    description: 'Moves diagonally',
                    pattern: [[0,1,0],[0,0,1],[1,1,1]]
                },
                blinker: {
                    name: 'Blinker',
                    description: 'Oscillates',
                    pattern: [[1],[1],[1]]
                },
                block: {
                    name: 'Block',
                    description: 'Still life',
                    pattern: [[1,1],[1,1]]
                },
                toad: {
                    name: 'Toad',
                    description: 'Period-2 oscillator',
                    pattern: [[0,1,1,1],[1,1,1,0]]
                }
            };
            
            const component = {
                render() {
                    return {
                        div: {
                            className: 'patterns-panel',
                            children: [
                                { h3: { text: '🎨 Patterns' } },
                                ...Object.entries(patterns).map(([key, pattern]) => ({
                                    div: {
                                        className: 'pattern-item',
                                        key,
                                        onClick: () => component.placePattern(pattern.pattern),
                                        children: [
                                            { div: { className: 'pattern-name', text: pattern.name } },
                                            { div: { className: 'pattern-description', text: pattern.description } }
                                        ]
                                    }
                                }))
                            ]
                        }
                    };
                },

                placePattern(pattern) {
                    const engine = window.gameOfLife?.getComponent('GameEngine');
                    if (engine) {
                        const startX = Math.floor((30 - pattern[0].length) / 2);
                        const startY = Math.floor((20 - pattern.length) / 2);
                        engine.placePattern(pattern, startX, startY);
                    }
                }
            };
            
            return component;
        };

        // Main Game Component
        const GameOfLife = (props, context) => {
            return {
                render() {
                    return {
                        div: {
                            className: 'game-container',
                            children: [
                                // Performance Notice
                                {
                                    div: {
                                        className: 'performance-notice',
                                        children: [
                                            { h3: { text: '⚡ Juris Framework Performance Test' } },
                                            { p: { text: 'Testing with exactly 600 cells (30×20 grid) - Intensive performance test!' } }
                                        ]
                                    }
                                },
                                
                                // Header
                                {
                                    div: {
                                        className: 'header',
                                        children: [
                                            { h1: { text: "🎮 Conway's Game of Life" } },
                                            { p: { text: 'Juris Framework Performance Test - 600 Cells' } },
                                            {
                                                div: {
                                                    className: 'generation-counter',
                                                    text: () => `Generation: ${context.getState('game.generation', 0)}`
                                                }
                                            }
                                        ]
                                    }
                                },
                                
                                // Controls
                                { GameControls: {} },
                                
                                // Game area
                                {
                                    div: {
                                        className: 'game-area',
                                        children: [
                                            // Grid container
                                            {
                                                div: {
                                                    className: 'grid-container',
                                                    children: [
                                                        { Grid: {} }
                                                    ]
                                                }
                                            },
                                            
                                            // Sidebar
                                            {
                                                div: {
                                                    className: 'sidebar',
                                                    children: [
                                                        { Statistics: {} },
                                                        { PerformancePanel: {} },
                                                        { PatternsPanel: {} }
                                                    ]
                                                }
                                            }
                                        ]
                                    }
                                },
                                
                                // Hidden components
                                { GameEngine: { key: 'GameEngine' } }
                            ]
                        }
                    };
                }
            };
        };

        // Initialize the Game of Life app
        const app = new Juris({
            components: {
                Cell,
                Grid,
                GameEngine,
                Statistics,
                PerformancePanel,
                GameControls,
                PatternsPanel,
                GameOfLife
            },
            
            layout: {
                div: {
                    children: [
                        { GameOfLife: {} }
                    ]
                }
            }
        });

        // Render the app
        app.render('#app');

        // Make app globally available for performance testing
        window.gameOfLife = app;

        console.log('🎮 Juris Game of Life Performance Test loaded!');
        console.log('✅ 600 cells (30×20 grid)');
        console.log('✅ Fixed accuracy issues with two-phase updates');
        console.log('✅ Performance metrics tracking');
        console.log('📊 Watch the Performance Metrics panel for Juris framework performance data');

        // Auto-start with a glider pattern for testing
        setTimeout(() => {
            const engine = app.getComponent('GameEngine');
            if (engine) {
                engine.placePattern([[0,1,0],[0,0,1],[1,1,1]], 13, 8); // Glider
                console.log('🚀 Started with glider pattern for performance testing!');
            }
        }, 1000);
    </script>
</body>
</html>